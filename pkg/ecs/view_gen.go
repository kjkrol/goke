// Code generated by gen/views; DO NOT EDIT.
package ecs

import (
	"github.com/kjkrol/goke/internal/core"
	"iter"
	"unsafe"
)

type View1[T1 any] struct {
	*core.View
}

func NewView1[T1 any](eng *Engine, options ...ViewOption) *View1[T1] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View1[T1]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head1[T1 any] struct {
	Entity Entity
	V1     *T1
}

type VHead1[T1 any] struct {
	V1 *T1
}

// --- All / Filter ---

func (q *View1[T1]) All() iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head1[T1]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1),
				}

				if !yield(head) {
					return
				}

				p1 = unsafe.Add(p1, s1)

			}
		}
	}
}

func (q *View1[T1]) Filter(selected []Entity) iter.Seq[Head1[T1]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head1[T1]) bool) {
		var lastArch *core.Archetype
		var cols [1]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 1; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head1[T1]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)),
			}

			if !yield(head) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View1[T1]) Values() iter.Seq[VHead1[T1]] {
	return func(yield func(VHead1[T1]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead1[T1]{V1: (*T1)(p1)}

				if !yield(vhead) {
					return
				}

				p1 = unsafe.Add(p1, s1)

			}
		}
	}
}

func (q *View1[T1]) FilterValues(selected []Entity) iter.Seq[VHead1[T1]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead1[T1]) bool) {
		var lastArch *core.Archetype
		var cols [1]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 1; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead1[T1]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize))}

			if !yield(vhead) {
				return
			}

		}
	}
}

type View2[T1, T2 any] struct {
	*core.View
}

func NewView2[T1, T2 any](eng *Engine, options ...ViewOption) *View2[T1, T2] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View2[T1, T2]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head2[T1, T2 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
}

type VHead2[T1, T2 any] struct {
	V1 *T1
	V2 *T2
}

// --- All / Filter ---

func (q *View2[T1, T2]) All() iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head2[T1, T2]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2),
				}

				if !yield(head) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)

			}
		}
	}
}

func (q *View2[T1, T2]) Filter(selected []Entity) iter.Seq[Head2[T1, T2]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head2[T1, T2]) bool) {
		var lastArch *core.Archetype
		var cols [2]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 2; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head2[T1, T2]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)),
			}

			if !yield(head) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View2[T1, T2]) Values() iter.Seq[VHead2[T1, T2]] {
	return func(yield func(VHead2[T1, T2]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead2[T1, T2]{V1: (*T1)(p1), V2: (*T2)(p2)}

				if !yield(vhead) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)

			}
		}
	}
}

func (q *View2[T1, T2]) FilterValues(selected []Entity) iter.Seq[VHead2[T1, T2]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead2[T1, T2]) bool) {
		var lastArch *core.Archetype
		var cols [2]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 2; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead2[T1, T2]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize))}

			if !yield(vhead) {
				return
			}

		}
	}
}

type View3[T1, T2, T3 any] struct {
	*core.View
}

func NewView3[T1, T2, T3 any](eng *Engine, options ...ViewOption) *View3[T1, T2, T3] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View3[T1, T2, T3]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head3[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type VHead3[T1, T2, T3 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
}

// --- All / Filter ---

func (q *View3[T1, T2, T3]) All() iter.Seq[Head3[T1, T2, T3]] {
	return func(yield func(Head3[T1, T2, T3]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head3[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				if !yield(head) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)

			}
		}
	}
}

func (q *View3[T1, T2, T3]) Filter(selected []Entity) iter.Seq[Head3[T1, T2, T3]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head3[T1, T2, T3]) bool) {
		var lastArch *core.Archetype
		var cols [3]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 3; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head3[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			if !yield(head) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View3[T1, T2, T3]) Values() iter.Seq[VHead3[T1, T2, T3]] {
	return func(yield func(VHead3[T1, T2, T3]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead3[T1, T2, T3]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}

				if !yield(vhead) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)

			}
		}
	}
}

func (q *View3[T1, T2, T3]) FilterValues(selected []Entity) iter.Seq[VHead3[T1, T2, T3]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead3[T1, T2, T3]) bool) {
		var lastArch *core.Archetype
		var cols [3]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 3; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead3[T1, T2, T3]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize))}

			if !yield(vhead) {
				return
			}

		}
	}
}

type View4[T1, T2, T3, T4 any] struct {
	*core.View
}

func NewView4[T1, T2, T3, T4 any](eng *Engine, options ...ViewOption) *View4[T1, T2, T3, T4] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View4[T1, T2, T3, T4]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head4[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type Tail4[T4 any] struct {
	V4 *T4
}

type VHead4[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}

// --- All / Filter ---

func (q *View4[T1, T2, T3, T4]) All() iter.Seq2[Head4[T1, T2, T3], Tail4[T4]] {
	return func(yield func(Head4[T1, T2, T3], Tail4[T4]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head4[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				tail := Tail4[T4]{V4: (*T4)(p4)}
				if !yield(head, tail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)

			}
		}
	}
}

func (q *View4[T1, T2, T3, T4]) Filter(selected []Entity) iter.Seq2[Head4[T1, T2, T3], Tail4[T4]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head4[T1, T2, T3], Tail4[T4]) bool) {
		var lastArch *core.Archetype
		var cols [4]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 4; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head4[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			tail := Tail4[T4]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View4[T1, T2, T3, T4]) Values() iter.Seq[VHead4[T1, T2, T3, T4]] {
	return func(yield func(VHead4[T1, T2, T3, T4]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead4[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}

				if !yield(vhead) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)

			}
		}
	}
}

func (q *View4[T1, T2, T3, T4]) FilterValues(selected []Entity) iter.Seq[VHead4[T1, T2, T3, T4]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead4[T1, T2, T3, T4]) bool) {
		var lastArch *core.Archetype
		var cols [4]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 4; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead4[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}

			if !yield(vhead) {
				return
			}

		}
	}
}

type View5[T1, T2, T3, T4, T5 any] struct {
	*core.View
}

func NewView5[T1, T2, T3, T4, T5 any](eng *Engine, options ...ViewOption) *View5[T1, T2, T3, T4, T5] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)
	core.OnCompType[T5](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View5[T1, T2, T3, T4, T5]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head5[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type Tail5[T4, T5 any] struct {
	V4 *T4
	V5 *T5
}

type VHead5[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}

type VTail5[T5 any] struct {
	V5 *T5
}

// --- All / Filter ---

func (q *View5[T1, T2, T3, T4, T5]) All() iter.Seq2[Head5[T1, T2, T3], Tail5[T4, T5]] {
	return func(yield func(Head5[T1, T2, T3], Tail5[T4, T5]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head5[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				tail := Tail5[T4, T5]{V4: (*T4)(p4), V5: (*T5)(p5)}
				if !yield(head, tail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)

			}
		}
	}
}

func (q *View5[T1, T2, T3, T4, T5]) Filter(selected []Entity) iter.Seq2[Head5[T1, T2, T3], Tail5[T4, T5]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head5[T1, T2, T3], Tail5[T4, T5]) bool) {
		var lastArch *core.Archetype
		var cols [5]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 5; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head5[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			tail := Tail5[T4, T5]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize)), V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View5[T1, T2, T3, T4, T5]) Values() iter.Seq2[VHead5[T1, T2, T3, T4], VTail5[T5]] {
	return func(yield func(VHead5[T1, T2, T3, T4], VTail5[T5]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead5[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}

				vtail := VTail5[T5]{V5: (*T5)(p5)}
				if !yield(vhead, vtail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)

			}
		}
	}
}

func (q *View5[T1, T2, T3, T4, T5]) FilterValues(selected []Entity) iter.Seq2[VHead5[T1, T2, T3, T4], VTail5[T5]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead5[T1, T2, T3, T4], VTail5[T5]) bool) {
		var lastArch *core.Archetype
		var cols [5]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 5; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead5[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}

			vtail := VTail5[T5]{V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize))}
			if !yield(vhead, vtail) {
				return
			}

		}
	}
}

type View6[T1, T2, T3, T4, T5, T6 any] struct {
	*core.View
}

func NewView6[T1, T2, T3, T4, T5, T6 any](eng *Engine, options ...ViewOption) *View6[T1, T2, T3, T4, T5, T6] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)
	core.OnCompType[T5](viewBuilder)
	core.OnCompType[T6](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View6[T1, T2, T3, T4, T5, T6]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head6[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type Tail6[T4, T5, T6 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
}

type VHead6[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}

type VTail6[T5, T6 any] struct {
	V5 *T5
	V6 *T6
}

// --- All / Filter ---

func (q *View6[T1, T2, T3, T4, T5, T6]) All() iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head6[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				tail := Tail6[T4, T5, T6]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6)}
				if !yield(head, tail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)

			}
		}
	}
}

func (q *View6[T1, T2, T3, T4, T5, T6]) Filter(selected []Entity) iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		var lastArch *core.Archetype
		var cols [6]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 6; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head6[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			tail := Tail6[T4, T5, T6]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize)), V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View6[T1, T2, T3, T4, T5, T6]) Values() iter.Seq2[VHead6[T1, T2, T3, T4], VTail6[T5, T6]] {
	return func(yield func(VHead6[T1, T2, T3, T4], VTail6[T5, T6]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead6[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}

				vtail := VTail6[T5, T6]{V5: (*T5)(p5), V6: (*T6)(p6)}
				if !yield(vhead, vtail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)

			}
		}
	}
}

func (q *View6[T1, T2, T3, T4, T5, T6]) FilterValues(selected []Entity) iter.Seq2[VHead6[T1, T2, T3, T4], VTail6[T5, T6]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead6[T1, T2, T3, T4], VTail6[T5, T6]) bool) {
		var lastArch *core.Archetype
		var cols [6]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 6; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead6[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}

			vtail := VTail6[T5, T6]{V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize))}
			if !yield(vhead, vtail) {
				return
			}

		}
	}
}

type View7[T1, T2, T3, T4, T5, T6, T7 any] struct {
	*core.View
}

func NewView7[T1, T2, T3, T4, T5, T6, T7 any](eng *Engine, options ...ViewOption) *View7[T1, T2, T3, T4, T5, T6, T7] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)
	core.OnCompType[T5](viewBuilder)
	core.OnCompType[T6](viewBuilder)
	core.OnCompType[T7](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View7[T1, T2, T3, T4, T5, T6, T7]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head7[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type Tail7[T4, T5, T6, T7 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
}

type VHead7[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}

type VTail7[T5, T6, T7 any] struct {
	V5 *T5
	V6 *T6
	V7 *T7
}

// --- All / Filter ---

func (q *View7[T1, T2, T3, T4, T5, T6, T7]) All() iter.Seq2[Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]] {
	return func(yield func(Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head7[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				tail := Tail7[T4, T5, T6, T7]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7)}
				if !yield(head, tail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)

			}
		}
	}
}

func (q *View7[T1, T2, T3, T4, T5, T6, T7]) Filter(selected []Entity) iter.Seq2[Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]) bool) {
		var lastArch *core.Archetype
		var cols [7]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 7; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head7[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			tail := Tail7[T4, T5, T6, T7]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize)), V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View7[T1, T2, T3, T4, T5, T6, T7]) Values() iter.Seq2[VHead7[T1, T2, T3, T4], VTail7[T5, T6, T7]] {
	return func(yield func(VHead7[T1, T2, T3, T4], VTail7[T5, T6, T7]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead7[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}

				vtail := VTail7[T5, T6, T7]{V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7)}
				if !yield(vhead, vtail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)

			}
		}
	}
}

func (q *View7[T1, T2, T3, T4, T5, T6, T7]) FilterValues(selected []Entity) iter.Seq2[VHead7[T1, T2, T3, T4], VTail7[T5, T6, T7]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead7[T1, T2, T3, T4], VTail7[T5, T6, T7]) bool) {
		var lastArch *core.Archetype
		var cols [7]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 7; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead7[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}

			vtail := VTail7[T5, T6, T7]{V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize))}
			if !yield(vhead, vtail) {
				return
			}

		}
	}
}

type View8[T1, T2, T3, T4, T5, T6, T7, T8 any] struct {
	*core.View
}

func NewView8[T1, T2, T3, T4, T5, T6, T7, T8 any](eng *Engine, options ...ViewOption) *View8[T1, T2, T3, T4, T5, T6, T7, T8] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)
	core.OnCompType[T5](viewBuilder)
	core.OnCompType[T6](viewBuilder)
	core.OnCompType[T7](viewBuilder)
	core.OnCompType[T8](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View8[T1, T2, T3, T4, T5, T6, T7, T8]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head8[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type Tail8[T4, T5, T6, T7, T8 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}

type VHead8[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}

type VTail8[T5, T6, T7, T8 any] struct {
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}

// --- All / Filter ---

func (q *View8[T1, T2, T3, T4, T5, T6, T7, T8]) All() iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize
			p8, s8 := b.Columns[7].Data, b.Columns[7].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head8[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				tail := Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7), V8: (*T8)(p8)}
				if !yield(head, tail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
				p8 = unsafe.Add(p8, s8)

			}
		}
	}
}

func (q *View8[T1, T2, T3, T4, T5, T6, T7, T8]) Filter(selected []Entity) iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		var lastArch *core.Archetype
		var cols [8]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 8; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head8[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			tail := Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize)), V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize)), V8: (*T8)(unsafe.Add(cols[7].Data, idx*cols[7].ItemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View8[T1, T2, T3, T4, T5, T6, T7, T8]) Values() iter.Seq2[VHead8[T1, T2, T3, T4], VTail8[T5, T6, T7, T8]] {
	return func(yield func(VHead8[T1, T2, T3, T4], VTail8[T5, T6, T7, T8]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize
			p8, s8 := b.Columns[7].Data, b.Columns[7].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead8[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}

				vtail := VTail8[T5, T6, T7, T8]{V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7), V8: (*T8)(p8)}
				if !yield(vhead, vtail) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
				p8 = unsafe.Add(p8, s8)

			}
		}
	}
}

func (q *View8[T1, T2, T3, T4, T5, T6, T7, T8]) FilterValues(selected []Entity) iter.Seq2[VHead8[T1, T2, T3, T4], VTail8[T5, T6, T7, T8]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead8[T1, T2, T3, T4], VTail8[T5, T6, T7, T8]) bool) {
		var lastArch *core.Archetype
		var cols [8]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 8; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead8[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}

			vtail := VTail8[T5, T6, T7, T8]{V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize)), V8: (*T8)(unsafe.Add(cols[7].Data, idx*cols[7].ItemSize))}
			if !yield(vhead, vtail) {
				return
			}

		}
	}
}
