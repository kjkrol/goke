// Code generated by ecs/gen; DO NOT EDIT.
package ecs
import (
	"iter"
	"unsafe"
)
// -------------Query1-------------
type Head1[T1 any] struct {
	Entity Entity
	V1 *T1
}

func All1[T1 any](v *View1[T1]) iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			for j := 0; j < b.count; j++ {
				if !yield(Head1[T1]{Entity: b.entities[j], V1: (*T1)(p1)}) { return }
				p1 = unsafe.Add(p1, s1)
			}
		}
	}
}

func Filter1[T1 any](v *View1[T1], entities []Entity) iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		var lastArch *Archetype; var cols [1]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 1; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head1[T1]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize))}) { return }
		}
	}
}
// -------------Query2-------------
type Head2[T1, T2 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
}

func All2[T1, T2 any](v *View2[T1, T2]) iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			for j := 0; j < b.count; j++ {
				if !yield(Head2[T1, T2]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
			}
		}
	}
}

func Filter2[T1, T2 any](v *View2[T1, T2], entities []Entity) iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		var lastArch *Archetype; var cols [2]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 2; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head2[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize))}) { return }
		}
	}
}
// -------------Query3-------------
type Head3[T1, T2 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
}
type Tail3[T3 any] struct {
	V3 *T3
}

func All3[T1, T2, T3 any](v *View3[T1, T2, T3]) iter.Seq2[Head3[T1, T2], Tail3[T3]] {
	return func(yield func(Head3[T1, T2], Tail3[T3]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			for j := 0; j < b.count; j++ {
				if !yield(Head3[T1, T2]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2)}, Tail3[T3]{V3: (*T3)(p3)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
			}
		}
	}
}

func Filter3[T1, T2, T3 any](v *View3[T1, T2, T3], entities []Entity) iter.Seq2[Head3[T1, T2], Tail3[T3]] {
	return func(yield func(Head3[T1, T2], Tail3[T3]) bool) {
		var lastArch *Archetype; var cols [3]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 3; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head3[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize))}, Tail3[T3]{V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize))}) { return }
		}
	}
}
// -------------Query4-------------
type Head4[T1, T2 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
}
type Tail4[T3, T4 any] struct {
	V3 *T3
	V4 *T4
}

func All4[T1, T2, T3, T4 any](v *View4[T1, T2, T3, T4]) iter.Seq2[Head4[T1, T2], Tail4[T3, T4]] {
	return func(yield func(Head4[T1, T2], Tail4[T3, T4]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			p4, s4 := b.ptrs[3], b.sizes[3]
			for j := 0; j < b.count; j++ {
				if !yield(Head4[T1, T2]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2)}, Tail4[T3, T4]{V3: (*T3)(p3), V4: (*T4)(p4)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
			}
		}
	}
}

func Filter4[T1, T2, T3, T4 any](v *View4[T1, T2, T3, T4], entities []Entity) iter.Seq2[Head4[T1, T2], Tail4[T3, T4]] {
	return func(yield func(Head4[T1, T2], Tail4[T3, T4]) bool) {
		var lastArch *Archetype; var cols [4]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 4; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head4[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize))}, Tail4[T3, T4]{V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize)), V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize))}) { return }
		}
	}
}
// -------------Query5-------------
type Head5[T1, T2 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
}
type Tail5[T3, T4, T5 any] struct {
	V3 *T3
	V4 *T4
	V5 *T5
}

func All5[T1, T2, T3, T4, T5 any](v *View5[T1, T2, T3, T4, T5]) iter.Seq2[Head5[T1, T2], Tail5[T3, T4, T5]] {
	return func(yield func(Head5[T1, T2], Tail5[T3, T4, T5]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			p4, s4 := b.ptrs[3], b.sizes[3]
			p5, s5 := b.ptrs[4], b.sizes[4]
			for j := 0; j < b.count; j++ {
				if !yield(Head5[T1, T2]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2)}, Tail5[T3, T4, T5]{V3: (*T3)(p3), V4: (*T4)(p4), V5: (*T5)(p5)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
			}
		}
	}
}

func Filter5[T1, T2, T3, T4, T5 any](v *View5[T1, T2, T3, T4, T5], entities []Entity) iter.Seq2[Head5[T1, T2], Tail5[T3, T4, T5]] {
	return func(yield func(Head5[T1, T2], Tail5[T3, T4, T5]) bool) {
		var lastArch *Archetype; var cols [5]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 5; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head5[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize))}, Tail5[T3, T4, T5]{V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize)), V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize)), V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize))}) { return }
		}
	}
}
// -------------Query6-------------
type Head6[T1, T2, T3 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
	V3 *T3
}
type Tail6[T4, T5, T6 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
}

func All6[T1, T2, T3, T4, T5, T6 any](v *View6[T1, T2, T3, T4, T5, T6]) iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			p4, s4 := b.ptrs[3], b.sizes[3]
			p5, s5 := b.ptrs[4], b.sizes[4]
			p6, s6 := b.ptrs[5], b.sizes[5]
			for j := 0; j < b.count; j++ {
				if !yield(Head6[T1, T2, T3]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}, Tail6[T4, T5, T6]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
			}
		}
	}
}

func Filter6[T1, T2, T3, T4, T5, T6 any](v *View6[T1, T2, T3, T4, T5, T6], entities []Entity) iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		var lastArch *Archetype; var cols [6]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 6; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head6[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize)), V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize))}, Tail6[T4, T5, T6]{V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize)), V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize)), V6: (*T6)(unsafe.Add(cols[5].data, idx*cols[5].itemSize))}) { return }
		}
	}
}
// -------------Query7-------------
type Head7[T1, T2, T3 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
	V3 *T3
}
type Tail7[T4, T5, T6, T7 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
}

func All7[T1, T2, T3, T4, T5, T6, T7 any](v *View7[T1, T2, T3, T4, T5, T6, T7]) iter.Seq2[Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]] {
	return func(yield func(Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			p4, s4 := b.ptrs[3], b.sizes[3]
			p5, s5 := b.ptrs[4], b.sizes[4]
			p6, s6 := b.ptrs[5], b.sizes[5]
			p7, s7 := b.ptrs[6], b.sizes[6]
			for j := 0; j < b.count; j++ {
				if !yield(Head7[T1, T2, T3]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}, Tail7[T4, T5, T6, T7]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
			}
		}
	}
}

func Filter7[T1, T2, T3, T4, T5, T6, T7 any](v *View7[T1, T2, T3, T4, T5, T6, T7], entities []Entity) iter.Seq2[Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]] {
	return func(yield func(Head7[T1, T2, T3], Tail7[T4, T5, T6, T7]) bool) {
		var lastArch *Archetype; var cols [7]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 7; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head7[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize)), V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize))}, Tail7[T4, T5, T6, T7]{V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize)), V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize)), V6: (*T6)(unsafe.Add(cols[5].data, idx*cols[5].itemSize)), V7: (*T7)(unsafe.Add(cols[6].data, idx*cols[6].itemSize))}) { return }
		}
	}
}
// -------------Query8-------------
type Head8[T1, T2, T3 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
	V3 *T3
}
type Tail8[T4, T5, T6, T7, T8 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}

func All8[T1, T2, T3, T4, T5, T6, T7, T8 any](v *View8[T1, T2, T3, T4, T5, T6, T7, T8]) iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		for i := range v.baked {
			b := &v.baked[i]
			p1, s1 := b.ptrs[0], b.sizes[0]
			p2, s2 := b.ptrs[1], b.sizes[1]
			p3, s3 := b.ptrs[2], b.sizes[2]
			p4, s4 := b.ptrs[3], b.sizes[3]
			p5, s5 := b.ptrs[4], b.sizes[4]
			p6, s6 := b.ptrs[5], b.sizes[5]
			p7, s7 := b.ptrs[6], b.sizes[6]
			p8, s8 := b.ptrs[7], b.sizes[7]
			for j := 0; j < b.count; j++ {
				if !yield(Head8[T1, T2, T3]{Entity: b.entities[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}, Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7), V8: (*T8)(p8)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
				p8 = unsafe.Add(p8, s8)
			}
		}
	}
}

func Filter8[T1, T2, T3, T4, T5, T6, T7, T8 any](v *View8[T1, T2, T3, T4, T5, T6, T7, T8], entities []Entity) iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		var lastArch *Archetype; var cols [8]*column
		for _, e := range entities {
			link := v.entityArchLinks[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(v.mask) { continue }
			if arch != lastArch { for i := 0; i < 8; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head8[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize)), V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize))}, Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize)), V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize)), V6: (*T6)(unsafe.Add(cols[5].data, idx*cols[5].itemSize)), V7: (*T7)(unsafe.Add(cols[6].data, idx*cols[6].itemSize)), V8: (*T8)(unsafe.Add(cols[7].data, idx*cols[7].itemSize))}) { return }
		}
	}
}
