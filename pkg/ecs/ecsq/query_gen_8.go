// Code generated by gen/queries; DO NOT EDIT.
package ecsq
import (
	"iter"
	"unsafe"

	"github.com/kjkrol/goke/internal/core"
)

type Query8[T1, T2, T3, T4, T5, T6, T7, T8 any] struct {
	*core.View
}

func NewQuery8[T1, T2, T3, T4, T5, T6, T7, T8 any](reg *core.Registry, options ...core.ViewOption) *Query8[T1, T2, T3, T4, T5, T6, T7, T8] {
	viewBuilder := core.NewViewBuilder(reg)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)
	core.OnCompType[T4](viewBuilder)
	core.OnCompType[T5](viewBuilder)
	core.OnCompType[T6](viewBuilder)
	core.OnCompType[T7](viewBuilder)
	core.OnCompType[T8](viewBuilder)
	for _, opt := range options {
		opt(viewBuilder)
	}
	return &Query8[T1, T2, T3, T4, T5, T6, T7, T8]{View: viewBuilder.Build()}
}

type Head8[T1, T2, T3 any] struct {
	Entity core.Entity
	V1 *T1
	V2 *T2
	V3 *T3
}
type Tail8[T4, T5, T6, T7, T8 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}
type PHead8[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}
type PTail8[T5, T6, T7, T8 any] struct {
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}

func (q *Query8[T1, T2, T3, T4, T5, T6, T7, T8]) All8() iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize
			p8, s8 := b.Columns[7].Data, b.Columns[7].ItemSize
			for j := 0; j < *b.Len; j++ {
				if !yield(Head8[T1, T2, T3]{Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}, Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7), V8: (*T8)(p8)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
				p8 = unsafe.Add(p8, s8)
			}
		}
	}
}

func (q *Query8[T1, T2, T3, T4, T5, T6, T7, T8]) Filter8(entities []core.Entity) iter.Seq2[Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head8[T1, T2, T3], Tail8[T4, T5, T6, T7, T8]) bool) {
		var lastArch *core.Archetype; var cols [8]*core.Column
		for _, e := range entities {
			link := links.Get(e.Index()); arch := link.Arch
			if arch == nil || q.View.Matches(arch.Mask) { continue }
			if arch != lastArch { for i := 0; i < 8; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }
			idx := uintptr(link.Row)
			if !yield(Head8[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize))}, Tail8[T4, T5, T6, T7, T8]{V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize)), V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize)), V8: (*T8)(unsafe.Add(cols[7].Data, idx*cols[7].ItemSize))}) { return }
		}
	}
}

func (q *Query8[T1, T2, T3, T4, T5, T6, T7, T8]) PureAll8() iter.Seq2[PHead8[T1, T2, T3, T4], PTail8[T5, T6, T7, T8]] {
	return func(yield func(PHead8[T1, T2, T3, T4], PTail8[T5, T6, T7, T8]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize
			p4, s4 := b.Columns[3].Data, b.Columns[3].ItemSize
			p5, s5 := b.Columns[4].Data, b.Columns[4].ItemSize
			p6, s6 := b.Columns[5].Data, b.Columns[5].ItemSize
			p7, s7 := b.Columns[6].Data, b.Columns[6].ItemSize
			p8, s8 := b.Columns[7].Data, b.Columns[7].ItemSize
			for j := 0; j < *b.Len; j++ {
				if !yield(PHead8[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}, PTail8[T5, T6, T7, T8]{V5: (*T5)(p5), V6: (*T6)(p6), V7: (*T7)(p7), V8: (*T8)(p8)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
				p7 = unsafe.Add(p7, s7)
				p8 = unsafe.Add(p8, s8)
			}
		}
	}
}

func (q *Query8[T1, T2, T3, T4, T5, T6, T7, T8]) PureFilter8(entities []core.Entity) iter.Seq2[PHead8[T1, T2, T3, T4], PTail8[T5, T6, T7, T8]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(PHead8[T1, T2, T3, T4], PTail8[T5, T6, T7, T8]) bool) {
		var lastArch *core.Archetype; var cols [8]*core.Column
		for _, e := range entities {
			link := links.Get(e.Index()); arch := link.Arch
			if arch == nil || q.View.Matches(arch.Mask) { continue }
			if arch != lastArch { for i := 0; i < 8; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }
			idx := uintptr(link.Row)
			if !yield(PHead8[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)), V4: (*T4)(unsafe.Add(cols[3].Data, idx*cols[3].ItemSize))}, PTail8[T5, T6, T7, T8]{V5: (*T5)(unsafe.Add(cols[4].Data, idx*cols[4].ItemSize)), V6: (*T6)(unsafe.Add(cols[5].Data, idx*cols[5].ItemSize)), V7: (*T7)(unsafe.Add(cols[6].Data, idx*cols[6].ItemSize)), V8: (*T8)(unsafe.Add(cols[7].Data, idx*cols[7].ItemSize))}) { return }
		}
	}
}
