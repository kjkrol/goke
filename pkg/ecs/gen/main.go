package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

const viewTemplate = `// Code generated by go generate; DO NOT EDIT.
package ecs

import (
    "iter"
    "unsafe"
)

// -------------- Row Structures --------------

{{- range .Count}}
{{$n := .}}
{{- if le $n 3}}
type Head{{$n}}[{{params $n}} any] struct {
    Entity Entity
    {{fields $n 1}}
}

func (h Head{{$n}}[{{types $n}}]) Values() (Entity, {{params_ptrs $n}}) {
    return h.Entity, {{row_returns_prefix $n 1 "h"}}
}
{{- else}}
type Tail{{sub $n 3}}[{{args_tail_names $n}} any] struct {
    {{fields (sub $n 3) 4}}
}

func (t Tail{{sub $n 3}}[{{types_tail $n}}]) Values() ({{params_ptrs_tail $n}}) {
    return {{row_returns_prefix (sub $n 3) 4 "t"}}
}
{{- end}}
{{- end}}

{{- range .Count}}
{{$n := .}}
// -------------- View{{$n}} --------------

type matchedArch{{$n}}[{{params $n}} any] struct {
    arch     *Archetype
    entities []Entity
    count    int
    {{- range $i := seq $n}}
    ptr{{add $i 1}}  unsafe.Pointer
    size{{add $i 1}} uintptr
    {{- end}}
}

type View{{$n}}[{{params $n}} any] struct {
    viewBase
    ids   [{{$n}}]ComponentID
    baked []matchedArch{{$n}}[{{types $n}}]
}

func (v *View{{$n}}[{{types $n}}]) Reindex() {
    v.viewBase.Reindex()
    v.baked = v.baked[:0]
    for _, arch := range v.matched {
        if arch.len == 0 { continue }
        mArch := matchedArch{{$n}}[{{types $n}}]{
            arch:     arch,
            entities: arch.entities[:arch.len],
            count:    arch.len,
        }
        {{range $i := seq $n}}
        col{{add $i 1}} := arch.columns[v.ids[{{$i}}]]
        mArch.ptr{{add $i 1}}  = col{{add $i 1}}.data
        mArch.size{{add $i 1}} = col{{add $i 1}}.itemSize
        {{end}}
        v.baked = append(v.baked, mArch)
    }
}

func NewView{{$n}}[{{params $n}} any](reg *Registry) *View{{$n}}[{{types $n}}] {
    {{registration $n}}
    ids := [{{$n}}]ComponentID{ {{idList $n}} }
    
    var mask ArchetypeMask
    for _, id := range ids {
        mask = mask.Set(id)
    }

    v := &View{{$n}}[{{types $n}}]{
        viewBase: viewBase{
            reg: reg,
            mask: mask,
            entityArchLinks: reg.archetypeRegistry.entityArchLinks,
        },
        ids: ids,
    }
    v.Reindex() 
    return v
}

func (v *View{{$n}}[{{types $n}}]) All() {{if le $n 3}}iter.Seq[Head{{$n}}[{{types $n}}]]{{else}}iter.Seq2[Head3[T1, T2, T3], Tail{{sub $n 3}}[{{types_tail $n}}]]{{end}} {
    return func(yield {{if le $n 3}}func(Head{{$n}}[{{types $n}}]) bool{{else}}func(Head3[T1, T2, T3], Tail{{sub $n 3}}[{{types_tail $n}}]) bool{{end}}) {
        {{if le $n 3}}var row Head{{$n}}[{{types $n}}]{{else}}var head Head3[T1, T2, T3]; var tail Tail{{sub $n 3}}[{{types_tail $n}}]{{end}}
        
        for i := range v.baked {
            b := &v.baked[i]
            {{range $i := seq $n}}
            p{{add $i 1}} := b.ptr{{add $i 1}}
            s{{add $i 1}} := b.size{{add $i 1}}
            {{- end}}
            
            for j := 0; j < b.count; j++ {
                {{if le $n 3}}
                row.Entity = b.entities[j]
                {{range $i := seq $n}};row.V{{add $i 1}} = (*T{{add $i 1}})(p{{add $i 1}}){{end}}
                if !yield(row) { return }
                {{else}}
                head.Entity = b.entities[j]
                {{range $i := seq 3}};head.V{{add $i 1}} = (*T{{add $i 1}})(p{{add $i 1}}){{end}}
                {{range $i := seq (sub $n 3)}};tail.V{{add $i 4}} = (*T{{add $i 4}})(p{{add $i 4}}){{end}}
                if !yield(head, tail) { return }
                {{end}}

                // Przesunięcie wskaźników o rozmiar typu
                {{range $i := seq $n}}
                p{{add $i 1}} = unsafe.Add(p{{add $i 1}}, s{{add $i 1}})
                {{- end}}
            }
        }
    }
}

func (v *View{{$n}}[{{types $n}}]) Filtered(entities []Entity) {{if le $n 3}}iter.Seq[Head{{$n}}[{{types $n}}]]{{else}}iter.Seq2[Head3[T1, T2, T3], Tail{{sub $n 3}}[{{types_tail $n}}]]{{end}} {
    return func(yield {{if le $n 3}}func(Head{{$n}}[{{types $n}}]) bool{{else}}func(Head3[T1, T2, T3], Tail{{sub $n 3}}[{{types_tail $n}}]) bool{{end}}) {
        var lastArch *Archetype
        {{range $i := seq $n}}var c{{add $i 1}} *column; {{end}}

        for _, e := range entities {
            backLink := v.viewBase.entityArchLinks[e.Index()]
            arch := backLink.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                {{range $i := seq $n}}c{{add $i 1}} = arch.columns[v.ids[{{$i}}]]; {{end}}
                lastArch = arch
            }

            idx := backLink.row
            {{if le $n 3}}
            row := Head{{$n}}[{{types $n}}]{Entity: e, {{row_init_unsafe $n 1}} }
            if !yield(row) { return }
            {{else}}
            head := Head3[T1, T2, T3]{Entity: e, {{row_init_unsafe 3 1}} }
            tail := Tail{{sub $n 3}}[{{types_tail $n}}]{ {{row_init_unsafe (sub $n 3) 4}} }
            if !yield(head, tail) { return }
            {{end}}
        }
    }
}
{{end}}
`

func main() {
	funcMap := template.FuncMap{
		"add": func(a, b int) int { return a + b },
		"sub": func(a, b int) int { return a - b },
		"seq": func(n int) []int {
			res := make([]int, n)
			for i := 0; i < n; i++ {
				res[i] = i
			}
			return res
		},
		"params": func(n int) string {
			p := make([]string, n)
			for i := 0; i < n; i++ {
				p[i] = fmt.Sprintf("T%d", i+1)
			}
			return strings.Join(p, ", ")
		},
		"args_tail_names": func(n int) string {
			var p []string
			for i := 4; i <= n; i++ {
				p = append(p, fmt.Sprintf("T%d", i))
			}
			return strings.Join(p, ", ")
		},
		"types": func(n int) string {
			p := make([]string, n)
			for i := 0; i < n; i++ {
				p[i] = fmt.Sprintf("T%d", i+1)
			}
			return strings.Join(p, ", ")
		},
		"types_tail": func(n int) string {
			var p []string
			for i := 4; i <= n; i++ {
				p = append(p, fmt.Sprintf("T%d", i))
			}
			return strings.Join(p, ", ")
		},
		"fields": func(count, offset int) string {
			f := make([]string, count)
			for i := 0; i < count; i++ {
				idx := i + offset
				f[i] = fmt.Sprintf("V%d *T%d", idx, idx)
			}
			return strings.Join(f, "; ")
		},
		"params_ptrs": func(n int) string {
			p := make([]string, n)
			for i := 0; i < n; i++ {
				p[i] = fmt.Sprintf("*T%d", i+1)
			}
			return strings.Join(p, ", ")
		},
		"params_ptrs_tail": func(n int) string {
			var p []string
			for i := 4; i <= n; i++ {
				p = append(p, fmt.Sprintf("*T%d", i))
			}
			return strings.Join(p, ", ")
		},
		"row_returns_prefix": func(count, offset int, prefix string) string {
			var res []string
			for i := 0; i < count; i++ {
				idx := i + offset
				res = append(res, fmt.Sprintf("%s.V%d", prefix, idx))
			}
			return strings.Join(res, ", ")
		},
		"row_init": func(count, offset int) string {
			var res []string
			for i := 0; i < count; i++ {
				idx := i + offset
				res = append(res, fmt.Sprintf("V%d: &s%d[j]", idx, idx))
			}
			return strings.Join(res, ", ")
		},
		"row_init_unsafe": func(count, offset int) string {
			var res []string
			for i := 0; i < count; i++ {
				idx := i + offset
				res = append(res, fmt.Sprintf("V%d: (*T%d)(unsafe.Add(c%d.data, uintptr(idx)*c%d.itemSize))", idx, idx, idx, idx))
			}
			return strings.Join(res, ", ")
		},
		"registration": func(n int) string {
			var lines []string
			for i := 1; i <= n; i++ {
				lines = append(lines, fmt.Sprintf("id%d := ensureComponentRegistered[T%d](reg.componentsRegistry)", i, i))
			}
			return strings.Join(lines, "\n\t")
		},
		"idList": func(n int) string {
			var ids []string
			for i := 1; i <= n; i++ {
				ids = append(ids, fmt.Sprintf("id%d", i))
			}
			return strings.Join(ids, ", ")
		},
	}

	tmpl := template.Must(template.New("ecs").Funcs(funcMap).Parse(viewTemplate))
	f, err := os.Create("views_gen.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	tmpl.Execute(f, struct{ Count []int }{Count: []int{1, 2, 3, 4, 5, 6, 7, 8}})
}
