package main

import (
	"fmt"
	"os"
	"strings"
)

const MaxComponents = 8

type (
	Fi         func(*os.File)
	Fn         func(*os.File, int)
	Generators struct {
		Init Fi
		Next Fn
	}
)

func main() {
	filesGen := map[string]Generators{
		"views_gen.go": {Init: genViewPartImports, Next: genViewConstructorN},
		"query_gen.go": {Init: genQueryPartImports, Next: genQueryPartN},
	}
	for fileName, generator := range filesGen {
		file, err := os.Create(fileName)
		if err != nil {
			panic(err)
		}
		defer file.Close()

		fmt.Fprintln(file, "// Code generated by ecs/gen; DO NOT EDIT.")
		fmt.Fprintln(file, "package ecs")
		generator.Init(file)

		for i := 1; i <= MaxComponents; i++ {
			generator.Next(file, i)
		}
	}
}

func genViewPartImports(f *os.File) {}

func genViewConstructorN(f *os.File, n int) {
	idNames := make([]string, n)
	for i := 0; i < n; i++ {
		idNames[i] = fmt.Sprintf("id%d", i+1)
	}

	fmt.Fprintf(f, "\n// ------------- NewView%d -------------\n", n)

	// Sygnatura używa typów generycznych tylko do rejestracji komponentów
	tParams := ""
	for i := 1; i <= n; i++ {
		tParams += fmt.Sprintf("T%d", i)
		if i < n {
			tParams += ", "
		}
	}

	fmt.Fprintf(f, "func NewView%d[%s any](reg *Registry) *View {\n", n, tParams)

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\tid%d := ensureComponentRegistered[T%d](reg.componentsRegistry)\n", i, i)
	}

	fmt.Fprintf(f, "\tids := []ComponentID{%s}\n", strings.Join(idNames, ", "))
	fmt.Fprintf(f, "\tvar mask ArchetypeMask\n\tfor _, id := range ids { mask = mask.Set(id) }\n")

	fmt.Fprintf(f, "\tv := &View{reg: reg, mask: mask, ids: ids}\n")
	fmt.Fprintln(f, "\tv.Reindex()")
	fmt.Fprintln(f, "\treturn v\n}")
}

func genQueryPartImports(f *os.File) {
	fmt.Fprintln(f, "import (\n\t\"iter\"\n\t\"unsafe\"\n)")
}

func genQueryPartN(f *os.File, n int) {
	allTypes := make([]string, n)
	for i := 0; i < n; i++ {
		allTypes[i] = fmt.Sprintf("T%d", i+1)
	}

	fmt.Fprintf(f, "\n// ------------- Query%d -------------\n", n)

	// STANDARD (Entity + max 3 pola)
	hCount := n
	if hCount > 3 {
		hCount = 3
	}
	hTParams := strings.Join(allTypes[:hCount], ", ")

	fmt.Fprintf(f, "type Head%d[%s any] struct {\n\tEntity Entity\n", n, hTParams)
	for i := 1; i <= hCount; i++ {
		fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
	}
	fmt.Fprintln(f, "}")

	if n > hCount {
		tTParams := strings.Join(allTypes[hCount:], ", ")
		fmt.Fprintf(f, "type Tail%d[%s any] struct {\n", n, tTParams)
		// Obsługa rozbicia dla n > 7 (np. View8) zgodnie z Twoją logiką
		for i := hCount + 1; i <= n; i++ {
			if i == 8 && n == 8 { // Specyficzny przypadek V8 dla View8
				fmt.Fprintf(f, "\tV8 *T8\n")
				break
			}
			if i > hCount+4 {
				break
			} // Max 4 pola w Tail (poza V8)
			fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
		}
		fmt.Fprintln(f, "}")
	}

	// PURE (max 4 + 4)
	phCount := n
	if phCount > 4 {
		phCount = 4
	}
	phTParams := strings.Join(allTypes[:phCount], ", ")

	fmt.Fprintf(f, "type PHead%d[%s any] struct {\n", n, phTParams)
	for i := 1; i <= phCount; i++ {
		fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
	}
	fmt.Fprintln(f, "}")

	if n > phCount {
		ptTParams := strings.Join(allTypes[phCount:], ", ")
		fmt.Fprintf(f, "type PTail%d[%s any] struct {\n", n, ptTParams)
		for i := phCount + 1; i <= n; i++ {
			fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
		}
		fmt.Fprintln(f, "}")
	}

	allTParams := strings.Join(allTypes, ", ")
	tTParams := ""
	if n > hCount {
		tTParams = strings.Join(allTypes[hCount:], ", ")
	}
	ptTParams := ""
	if n > phCount {
		ptTParams = strings.Join(allTypes[phCount:], ", ")
	}

	// Wywołania generatorów funkcji korzystających z *View
	genAll(f, n, allTParams, hTParams, tTParams, hCount)
	genFilter(f, n, allTParams, hTParams, tTParams, hCount)
	genPureAll(f, n, allTParams, phTParams, ptTParams, phCount)
	genPureFilter(f, n, allTParams, phTParams, ptTParams, phCount)
}

func genAll(f *os.File, n int, allT, hT, tT string, hC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if n > hC {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}
	// ZMIANA: v *View zamiast v *ViewN
	fmt.Fprintf(f, "\nfunc All%d[%s any](v *View) %s[%s] {\n\treturn func(yield func(%s) bool) {\n\t\tfor i := range v.baked {\n\t\t\tb := &v.baked[i]\n", n, allT, seq, yield, yield)
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\tp%d, s%d := b.ptrs[%d], b.sizes[%d]\n", i, i, i-1, i-1)
	}
	fmt.Fprintln(f, "\t\t\tfor j := 0; j < b.count; j++ {")
	hI := fmt.Sprintf("Head%d[%s]{Entity: b.entities[j]", n, hT)
	for i := 1; i <= hC; i++ {
		hI += fmt.Sprintf(", V%d: (*T%d)(p%d)", i, i, i)
	}
	hI += "}"
	if n > hC {
		tI := fmt.Sprintf("Tail%d[%s]{", n, tT)
		for i := hC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s) { return }\n", hI)
	}
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\t\tp%d = unsafe.Add(p%d, s%d)\n", i, i, i)
	}
	fmt.Fprintln(f, "\t\t\t}\n\t\t}\n\t}\n}")
}

func genFilter(f *os.File, n int, allT, hT, tT string, hC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if n > hC {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}
	// ZMIANA: v *View zamiast v *ViewN
	fmt.Fprintf(f, "\nfunc Filter%d[%s any](v *View, entities []Entity) %s[%s] {\n\tlinks := v.reg.archetypeRegistry.entityArchLinks\n\treturn func(yield func(%s) bool) {\n\t\tvar lastArch *Archetype; var cols [%d]*column\n\t\tfor _, e := range entities {\n\t\t\tlink := links[e.Index()]; arch := link.arch\n\t\t\tif arch == nil || !arch.mask.Contains(v.mask) { continue }\n\t\t\tif arch != lastArch { for i := 0; i < %d; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }\n\t\t\tidx := uintptr(link.row)\n", n, allT, seq, yield, yield, n, n)
	hI := fmt.Sprintf("Head%d[%s]{Entity: e", n, hT)
	for i := 1; i <= hC; i++ {
		hI += fmt.Sprintf(", V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))", i, i, i-1, i-1)
	}
	hI += "}"
	if n > hC {
		tI := fmt.Sprintf("Tail%d[%s]{", n, tT)
		for i := hC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))%s", i, i, i-1, i-1, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\tif !yield(%s) { return }\n", hI)
	}
	fmt.Fprintln(f, "\t\t}\n\t}\n}")
}

// genPureAll i genPureFilter analogicznie zmieniają v *ViewN na v *View
func genPureAll(f *os.File, n int, allT, phT, ptT string, phC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("PHead%d[%s]", n, phT)
	if n > phC {
		seq, yield = "iter.Seq2", fmt.Sprintf("PHead%d[%s], PTail%d[%s]", n, phT, n, ptT)
	}
	fmt.Fprintf(f, "\nfunc PureAll%d[%s any](v *View) %s[%s] {\n\treturn func(yield func(%s) bool) {\n\t\tfor i := range v.baked {\n\t\t\tb := &v.baked[i]\n", n, allT, seq, yield, yield)
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\tp%d, s%d := b.ptrs[%d], b.sizes[%d]\n", i, i, i-1, i-1)
	}
	fmt.Fprintln(f, "\t\t\tfor j := 0; j < b.count; j++ {")
	hI := fmt.Sprintf("PHead%d[%s]{", n, phT)
	for i := 1; i <= phC; i++ {
		hI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < phC, ", ", ""))
	}
	hI += "}"
	if n > phC {
		tI := fmt.Sprintf("PTail%d[%s]{", n, ptT)
		for i := phC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s) { return }\n", hI)
	}
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\t\tp%d = unsafe.Add(p%d, s%d)\n", i, i, i)
	}
	fmt.Fprintln(f, "\t\t\t}\n\t\t}\n\t}\n}")
}

func genPureFilter(f *os.File, n int, allT, phT, ptT string, phC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("PHead%d[%s]", n, phT)
	if n > phC {
		seq, yield = "iter.Seq2", fmt.Sprintf("PHead%d[%s], PTail%d[%s]", n, phT, n, ptT)
	}
	fmt.Fprintf(f, "\nfunc PureFilter%d[%s any](v *View, entities []Entity) %s[%s] {\n\tlinks := v.reg.archetypeRegistry.entityArchLinks\n\treturn func(yield func(%s) bool) {\n\t\tvar lastArch *Archetype; var cols [%d]*column\n\t\tfor _, e := range entities {\n\t\t\tlink := links[e.Index()]; arch := link.arch\n\t\t\tif arch == nil || !arch.mask.Contains(v.mask) { continue }\n\t\t\tif arch != lastArch { for i := 0; i < %d; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }\n\t\t\tidx := uintptr(link.row)\n", n, allT, seq, yield, yield, n, n)
	hI := fmt.Sprintf("PHead%d[%s]{", n, phT)
	for i := 1; i <= phC; i++ {
		hI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))%s", i, i, i-1, i-1, ternary(i < phC, ", ", ""))
	}
	hI += "}"
	if n > phC {
		tI := fmt.Sprintf("PTail%d[%s]{", n, ptT)
		for i := phC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))%s", i, i, i-1, i-1, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\tif !yield(%s) { return }\n", hI)
	}
	fmt.Fprintln(f, "\t\t}\n\t}\n}")
}

func ternary(cond bool, a, b string) string {
	if cond {
		return a
	}
	return b
}
