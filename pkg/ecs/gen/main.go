package main

import (
	"fmt"
	"os"
	"strings"
)

const MaxComponents = 8

type (
	Fi         func(*os.File)
	Fn         func(*os.File, int)
	Generators struct {
		Init Fi
		Next Fn
	}
)

func main() {
	filesGen := map[string]Generators{
		"views_gen.go": {Init: genViewPartImports, Next: genViewPartN},
		"query_gen.go": {Init: genQueryPartImports, Next: genQueryPartN},
	}
	for fileName, generator := range filesGen {
		file, err := os.Create(fileName)
		if err != nil {
			panic(err)
		}
		defer file.Close()

		fmt.Fprintln(file, "// Code generated by ecs/gen; DO NOT EDIT.")
		fmt.Fprintln(file, "package ecs")
		generator.Init(file)

		for i := 1; i <= MaxComponents; i++ {
			generator.Next(file, i)
		}
	}
}

func genViewPartImports(f *os.File) {
	fmt.Fprintln(f, "import (\n\t\"unsafe\"\n)")
}

func genViewPartN(f *os.File, n int) {
	allTypes := make([]string, n)
	idNames := make([]string, n)
	for i := 0; i < n; i++ {
		allTypes[i] = fmt.Sprintf("T%d", i+1)
		idNames[i] = fmt.Sprintf("id%d", i+1)
	}
	allTParams := strings.Join(allTypes, ", ")

	fmt.Fprintf(f, "// -------------View%d-------------", n)

	// Widoki i Archetypy
	fmt.Fprintf(f, "\ntype matchedArch%d struct {\n\tarch *Archetype; entities []Entity; count int; ptrs [%d]unsafe.Pointer; sizes [%d]uintptr\n}\n", n, n, n)
	fmt.Fprintf(f, "type View%d[%s any] struct {\n\tviewBase; ids [%d]ComponentID; baked []matchedArch%d\n}\n", n, allTParams, n, n)

	// NewView
	fmt.Fprintf(f, "\nfunc NewView%d[%s any](reg *Registry) *View%d[%s] {\n", n, allTParams, n, allTParams)
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\tid%d := ensureComponentRegistered[T%d](reg.componentsRegistry)\n", i, i)
	}
	fmt.Fprintf(f, "\tids := [%d]ComponentID{%s}\n", n, strings.Join(idNames, ", "))
	fmt.Fprintln(f, "\tvar mask ArchetypeMask")
	fmt.Fprintln(f, "\tfor _, id := range ids { mask = mask.Set(id) }")
	fmt.Fprintf(f, "\tv := &View%d[%s]{\n\t\tviewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},\n\t\tids: ids,\n\t}\n", n, allTParams)
	fmt.Fprintln(f, "\tv.Reindex(); return v\n}")

	// Reindex
	fmt.Fprintf(f, "\nfunc (v *View%d[%s]) Reindex() {\n\tv.viewBase.Reindex(); v.baked = v.baked[:0]\n", n, allTParams)
	fmt.Fprintf(f, "\tfor _, arch := range v.matched {\n\t\tif arch.len == 0 { continue }\n")
	fmt.Fprintf(f, "\t\tmArch := matchedArch%d{arch: arch, entities: arch.entities[:arch.len], count: arch.len}\n", n)
	fmt.Fprintf(f, "\t\tfor i := 0; i < %d; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }\n", n)
	fmt.Fprintln(f, "\t\tv.baked = append(v.baked, mArch)\n\t}\n}")
}

func genQueryPartImports(f *os.File) {
	fmt.Fprintln(f, "import (\n\t\"iter\"\n\t\"unsafe\"\n)")
}

func genQueryPartN(f *os.File, n int) {
	allTypes := make([]string, n)
	idNames := make([]string, n)
	for i := 0; i < n; i++ {
		allTypes[i] = fmt.Sprintf("T%d", i+1)
		idNames[i] = fmt.Sprintf("id%d", i+1)
	}
	allTParams := strings.Join(allTypes, ", ")

	fmt.Fprintf(f, "// -------------Query%d-------------", n)

	// Podział Head (E + max 3 ptr) i Tail (reszta)
	var hCount int
	switch {
	case n <= 2:
		hCount = n
	case n <= 5:
		hCount = 2
	default:
		hCount = 3
	}
	tCount := n - hCount

	// Struktury Head i Tail - eksportowane, tylko niezbędne generyki
	hTParams := strings.Join(allTypes[:hCount], ", ")
	fmt.Fprintf(f, "\ntype Head%d[%s any] struct {\n\tEntity Entity\n", n, hTParams)
	for i := 1; i <= hCount; i++ {
		fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
	}
	fmt.Fprintln(f, "}")

	var tTParams string
	if tCount > 0 {
		tTParams = strings.Join(allTypes[hCount:], ", ")
		fmt.Fprintf(f, "type Tail%d[%s any] struct {\n", n, tTParams)
		for i := hCount + 1; i <= n; i++ {
			fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
		}
		fmt.Fprintln(f, "}")
	}

	// Iterator AllN
	genAll(f, n, allTParams, hTParams, tTParams, hCount, tCount)

	// Iterator FilterN
	genFilter(f, n, allTParams, hTParams, tTParams, hCount, tCount)
}

func genAll(f *os.File, n int, allT, hT, tT string, hCount, tCount int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if tCount > 0 {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}

	fmt.Fprintf(f, "\nfunc All%d[%s any](v *View%d[%s]) %s[%s] {\n", n, allT, n, allT, seq, yield)
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n\t\tfor i := range v.baked {\n\t\t\tb := &v.baked[i]\n", yield)
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\tp%d, s%d := b.ptrs[%d], b.sizes[%d]\n", i, i, i-1, i-1)
	}
	fmt.Fprintln(f, "\t\t\tfor j := 0; j < b.count; j++ {")

	hArgs := []string{"Entity: b.entities[j]"}
	for i := 1; i <= hCount; i++ {
		hArgs = append(hArgs, fmt.Sprintf("V%d: (*T%d)(p%d)", i, i, i))
	}
	hInit := fmt.Sprintf("Head%d[%s]{%s}", n, hT, strings.Join(hArgs, ", "))

	if tCount > 0 {
		tArgs := []string{}
		for i := hCount + 1; i <= n; i++ {
			tArgs = append(tArgs, fmt.Sprintf("V%d: (*T%d)(p%d)", i, i, i))
		}
		tInit := fmt.Sprintf("Tail%d[%s]{%s}", n, tT, strings.Join(tArgs, ", "))
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s, %s) { return }\n", hInit, tInit)
	} else {
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s) { return }\n", hInit)
	}

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\t\tp%d = unsafe.Add(p%d, s%d)\n", i, i, i)
	}
	fmt.Fprintln(f, "\t\t\t}\n\t\t}\n\t}\n}")
}

func genFilter(f *os.File, n int, allT, hT, tT string, hCount, tCount int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if tCount > 0 {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}

	fmt.Fprintf(f, "\nfunc Filter%d[%s any](v *View%d[%s], entities []Entity) %s[%s] {\n", n, allT, n, allT, seq, yield)
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n", yield)
	fmt.Fprintf(f, "\t\tvar lastArch *Archetype; var cols [%d]*column\n", n)
	fmt.Fprintln(f, "\t\tfor _, e := range entities {\n\t\t\tlink := v.entityArchLinks[e.Index()]; arch := link.arch")
	fmt.Fprintln(f, "\t\t\tif arch == nil || !arch.mask.Contains(v.mask) { continue }")
	fmt.Fprintf(f, "\t\t\tif arch != lastArch { for i := 0; i < %d; i++ { cols[i] = arch.columns[v.ids[i]] }; lastArch = arch }\n", n)
	fmt.Fprintln(f, "\t\t\tidx := uintptr(link.row)")

	hArgs := []string{"Entity: e"}
	for i := 1; i <= hCount; i++ {
		hArgs = append(hArgs, fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))", i, i, i-1, i-1))
	}
	hInit := fmt.Sprintf("Head%d[%s]{%s}", n, hT, strings.Join(hArgs, ", "))

	if tCount > 0 {
		tArgs := []string{}
		for i := hCount + 1; i <= n; i++ {
			tArgs = append(tArgs, fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].data, idx*cols[%d].itemSize))", i, i, i-1, i-1))
		}
		tInit := fmt.Sprintf("Tail%d[%s]{%s}", n, tT, strings.Join(tArgs, ", "))
		fmt.Fprintf(f, "\t\t\tif !yield(%s, %s) { return }\n", hInit, tInit)
	} else {
		fmt.Fprintf(f, "\t\t\tif !yield(%s) { return }\n", hInit)
	}
	fmt.Fprintln(f, "\t\t}\n\t}\n}")
}
