// Code generated by go generate; DO NOT EDIT.
package ecs

import (
	"iter"
	"unsafe"
)



// -------------- View1 --------------

type View1[T1 any] struct {
	queryCore
	ids [1]ComponentID
}

type Row1[T1 any] struct {
	V1 *T1
}

func NewView1[T1 any](reg *Registry) *View1[T1] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)

	ids := [1]ComponentID{ id1 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View1[T1]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View1[T1]) All() iter.Seq2[Entity, Row1[T1]] {
	return func(yield func(Entity, Row1[T1]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row1[T1]{
					V1: (*T1)(ptr1),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
			}
		}
	}
}


// -------------- View2 --------------

type View2[T1 any, T2 any] struct {
	queryCore
	ids [2]ComponentID
}

type Row2[T1 any, T2 any] struct {
	V1 *T1; V2 *T2
}

func NewView2[T1 any, T2 any](reg *Registry) *View2[T1, T2] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)

	ids := [2]ComponentID{ id1, id2 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View2[T1, T2]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View2[T1, T2]) All() iter.Seq2[Entity, Row2[T1, T2]] {
	return func(yield func(Entity, Row2[T1, T2]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)
			ptr2 := arch.columns[v.ids[1]].data
			size2 := uintptr(arch.columns[v.ids[1]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row2[T1, T2]{
					V1: (*T1)(ptr1),
					V2: (*T2)(ptr2),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
			}
		}
	}
}


// -------------- View3 --------------

type View3[T1 any, T2 any, T3 any] struct {
	queryCore
	ids [3]ComponentID
}

type Row3[T1 any, T2 any, T3 any] struct {
	V1 *T1; V2 *T2; V3 *T3
}

func NewView3[T1 any, T2 any, T3 any](reg *Registry) *View3[T1, T2, T3] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)

	ids := [3]ComponentID{ id1, id2, id3 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View3[T1, T2, T3]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View3[T1, T2, T3]) All() iter.Seq2[Entity, Row3[T1, T2, T3]] {
	return func(yield func(Entity, Row3[T1, T2, T3]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)
			ptr2 := arch.columns[v.ids[1]].data
			size2 := uintptr(arch.columns[v.ids[1]].itemSize)
			ptr3 := arch.columns[v.ids[2]].data
			size3 := uintptr(arch.columns[v.ids[2]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row3[T1, T2, T3]{
					V1: (*T1)(ptr1),
					V2: (*T2)(ptr2),
					V3: (*T3)(ptr3),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
			}
		}
	}
}


// -------------- View4 --------------

type View4[T1 any, T2 any, T3 any, T4 any] struct {
	queryCore
	ids [4]ComponentID
}

type Row4[T1 any, T2 any, T3 any, T4 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4
}

func NewView4[T1 any, T2 any, T3 any, T4 any](reg *Registry) *View4[T1, T2, T3, T4] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)

	ids := [4]ComponentID{ id1, id2, id3, id4 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View4[T1, T2, T3, T4]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View4[T1, T2, T3, T4]) All() iter.Seq2[Entity, Row4[T1, T2, T3, T4]] {
	return func(yield func(Entity, Row4[T1, T2, T3, T4]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)
			ptr2 := arch.columns[v.ids[1]].data
			size2 := uintptr(arch.columns[v.ids[1]].itemSize)
			ptr3 := arch.columns[v.ids[2]].data
			size3 := uintptr(arch.columns[v.ids[2]].itemSize)
			ptr4 := arch.columns[v.ids[3]].data
			size4 := uintptr(arch.columns[v.ids[3]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row4[T1, T2, T3, T4]{
					V1: (*T1)(ptr1),
					V2: (*T2)(ptr2),
					V3: (*T3)(ptr3),
					V4: (*T4)(ptr4),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
			}
		}
	}
}


// -------------- View5 --------------

type View5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	queryCore
	ids [5]ComponentID
}

type Row5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4; V5 *T5
}

func NewView5[T1 any, T2 any, T3 any, T4 any, T5 any](reg *Registry) *View5[T1, T2, T3, T4, T5] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)

	ids := [5]ComponentID{ id1, id2, id3, id4, id5 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View5[T1, T2, T3, T4, T5]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View5[T1, T2, T3, T4, T5]) All() iter.Seq2[Entity, Row5[T1, T2, T3, T4, T5]] {
	return func(yield func(Entity, Row5[T1, T2, T3, T4, T5]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)
			ptr2 := arch.columns[v.ids[1]].data
			size2 := uintptr(arch.columns[v.ids[1]].itemSize)
			ptr3 := arch.columns[v.ids[2]].data
			size3 := uintptr(arch.columns[v.ids[2]].itemSize)
			ptr4 := arch.columns[v.ids[3]].data
			size4 := uintptr(arch.columns[v.ids[3]].itemSize)
			ptr5 := arch.columns[v.ids[4]].data
			size5 := uintptr(arch.columns[v.ids[4]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row5[T1, T2, T3, T4, T5]{
					V1: (*T1)(ptr1),
					V2: (*T2)(ptr2),
					V3: (*T3)(ptr3),
					V4: (*T4)(ptr4),
					V5: (*T5)(ptr5),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
				ptr5 = unsafe.Add(ptr5, size5)
			}
		}
	}
}


// -------------- View6 --------------

type View6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	queryCore
	ids [6]ComponentID
}

type Row6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4; V5 *T5; V6 *T6
}

func NewView6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](reg *Registry) *View6[T1, T2, T3, T4, T5, T6] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)

	ids := [6]ComponentID{ id1, id2, id3, id4, id5, id6 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	return &View6[T1, T2, T3, T4, T5, T6]{
		queryCore: newQueryCore(reg, mask),
		ids:       ids,
	}
}

func (v *View6[T1, T2, T3, T4, T5, T6]) All() iter.Seq2[Entity, Row6[T1, T2, T3, T4, T5, T6]] {
	return func(yield func(Entity, Row6[T1, T2, T3, T4, T5, T6]) bool) {
		for _, arch := range v.archetypes {
			ptr1 := arch.columns[v.ids[0]].data
			size1 := uintptr(arch.columns[v.ids[0]].itemSize)
			ptr2 := arch.columns[v.ids[1]].data
			size2 := uintptr(arch.columns[v.ids[1]].itemSize)
			ptr3 := arch.columns[v.ids[2]].data
			size3 := uintptr(arch.columns[v.ids[2]].itemSize)
			ptr4 := arch.columns[v.ids[3]].data
			size4 := uintptr(arch.columns[v.ids[3]].itemSize)
			ptr5 := arch.columns[v.ids[4]].data
			size5 := uintptr(arch.columns[v.ids[4]].itemSize)
			ptr6 := arch.columns[v.ids[5]].data
			size6 := uintptr(arch.columns[v.ids[5]].itemSize)

			for i := 0; i < arch.len; i++ {
				entity := arch.entities[i]
				row := Row6[T1, T2, T3, T4, T5, T6]{
					V1: (*T1)(ptr1),
					V2: (*T2)(ptr2),
					V3: (*T3)(ptr3),
					V4: (*T4)(ptr4),
					V5: (*T5)(ptr5),
					V6: (*T6)(ptr6),
				}

				if !yield(entity, row) {
					return
				}

				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
				ptr5 = unsafe.Add(ptr5, size5)
				ptr6 = unsafe.Add(ptr6, size6)
			}
		}
	}
}

