// Code generated by ecs/gen; DO NOT EDIT.
package ecs
import (
	"unsafe"
)
// -------------View1-------------
type matchedArch1 struct {
	arch *Archetype; entities []Entity; count int; ptrs [1]unsafe.Pointer; sizes [1]uintptr
}
type View1[T1 any] struct {
	viewBase; ids [1]ComponentID; baked []matchedArch1
}

func NewView1[T1 any](reg *Registry) *View1[T1] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	ids := [1]ComponentID{id1}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View1[T1]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View1[T1]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch1{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 1; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View2-------------
type matchedArch2 struct {
	arch *Archetype; entities []Entity; count int; ptrs [2]unsafe.Pointer; sizes [2]uintptr
}
type View2[T1, T2 any] struct {
	viewBase; ids [2]ComponentID; baked []matchedArch2
}

func NewView2[T1, T2 any](reg *Registry) *View2[T1, T2] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	ids := [2]ComponentID{id1, id2}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View2[T1, T2]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View2[T1, T2]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch2{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 2; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View3-------------
type matchedArch3 struct {
	arch *Archetype; entities []Entity; count int; ptrs [3]unsafe.Pointer; sizes [3]uintptr
}
type View3[T1, T2, T3 any] struct {
	viewBase; ids [3]ComponentID; baked []matchedArch3
}

func NewView3[T1, T2, T3 any](reg *Registry) *View3[T1, T2, T3] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	ids := [3]ComponentID{id1, id2, id3}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View3[T1, T2, T3]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View3[T1, T2, T3]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch3{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 3; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View4-------------
type matchedArch4 struct {
	arch *Archetype; entities []Entity; count int; ptrs [4]unsafe.Pointer; sizes [4]uintptr
}
type View4[T1, T2, T3, T4 any] struct {
	viewBase; ids [4]ComponentID; baked []matchedArch4
}

func NewView4[T1, T2, T3, T4 any](reg *Registry) *View4[T1, T2, T3, T4] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	ids := [4]ComponentID{id1, id2, id3, id4}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View4[T1, T2, T3, T4]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View4[T1, T2, T3, T4]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch4{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 4; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View5-------------
type matchedArch5 struct {
	arch *Archetype; entities []Entity; count int; ptrs [5]unsafe.Pointer; sizes [5]uintptr
}
type View5[T1, T2, T3, T4, T5 any] struct {
	viewBase; ids [5]ComponentID; baked []matchedArch5
}

func NewView5[T1, T2, T3, T4, T5 any](reg *Registry) *View5[T1, T2, T3, T4, T5] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	ids := [5]ComponentID{id1, id2, id3, id4, id5}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View5[T1, T2, T3, T4, T5]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View5[T1, T2, T3, T4, T5]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch5{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 5; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View6-------------
type matchedArch6 struct {
	arch *Archetype; entities []Entity; count int; ptrs [6]unsafe.Pointer; sizes [6]uintptr
}
type View6[T1, T2, T3, T4, T5, T6 any] struct {
	viewBase; ids [6]ComponentID; baked []matchedArch6
}

func NewView6[T1, T2, T3, T4, T5, T6 any](reg *Registry) *View6[T1, T2, T3, T4, T5, T6] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	ids := [6]ComponentID{id1, id2, id3, id4, id5, id6}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View6[T1, T2, T3, T4, T5, T6]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View6[T1, T2, T3, T4, T5, T6]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch6{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 6; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View7-------------
type matchedArch7 struct {
	arch *Archetype; entities []Entity; count int; ptrs [7]unsafe.Pointer; sizes [7]uintptr
}
type View7[T1, T2, T3, T4, T5, T6, T7 any] struct {
	viewBase; ids [7]ComponentID; baked []matchedArch7
}

func NewView7[T1, T2, T3, T4, T5, T6, T7 any](reg *Registry) *View7[T1, T2, T3, T4, T5, T6, T7] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	id7 := ensureComponentRegistered[T7](reg.componentsRegistry)
	ids := [7]ComponentID{id1, id2, id3, id4, id5, id6, id7}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View7[T1, T2, T3, T4, T5, T6, T7]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View7[T1, T2, T3, T4, T5, T6, T7]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch7{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 7; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
// -------------View8-------------
type matchedArch8 struct {
	arch *Archetype; entities []Entity; count int; ptrs [8]unsafe.Pointer; sizes [8]uintptr
}
type View8[T1, T2, T3, T4, T5, T6, T7, T8 any] struct {
	viewBase; ids [8]ComponentID; baked []matchedArch8
}

func NewView8[T1, T2, T3, T4, T5, T6, T7, T8 any](reg *Registry) *View8[T1, T2, T3, T4, T5, T6, T7, T8] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	id7 := ensureComponentRegistered[T7](reg.componentsRegistry)
	id8 := ensureComponentRegistered[T8](reg.componentsRegistry)
	ids := [8]ComponentID{id1, id2, id3, id4, id5, id6, id7, id8}
	var mask ArchetypeMask
	for _, id := range ids { mask = mask.Set(id) }
	v := &View8[T1, T2, T3, T4, T5, T6, T7, T8]{
		viewBase: viewBase{reg: reg, mask: mask, entityArchLinks: reg.archetypeRegistry.entityArchLinks},
		ids: ids,
	}
	v.Reindex(); return v
}

func (v *View8[T1, T2, T3, T4, T5, T6, T7, T8]) Reindex() {
	v.viewBase.Reindex(); v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 { continue }
		mArch := matchedArch8{arch: arch, entities: arch.entities[:arch.len], count: arch.len}
		for i := 0; i < 8; i++ { col := arch.columns[v.ids[i]]; mArch.ptrs[i] = col.data; mArch.sizes[i] = col.itemSize }
		v.baked = append(v.baked, mArch)
	}
}
