// Code generated by go generate; DO NOT EDIT.
package ecs

import (
	"iter"
	"unsafe"
)

// -------------- Row Structures --------------

type Head1[T1 any] struct {
	Entity Entity
	V1     *T1
}

func (h Head1[T1]) Values() (Entity, *T1) {
	return h.Entity, h.V1
}

type Head2[T1, T2 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
}

func (h Head2[T1, T2]) Values() (Entity, *T1, *T2) {
	return h.Entity, h.V1, h.V2
}

type Head3[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

func (h Head3[T1, T2, T3]) Values() (Entity, *T1, *T2, *T3) {
	return h.Entity, h.V1, h.V2, h.V3
}

type Tail1[T4 any] struct {
	V4 *T4
}

func (t Tail1[T4]) Values() *T4 {
	return t.V4
}

type Tail2[T4, T5 any] struct {
	V4 *T4
	V5 *T5
}

func (t Tail2[T4, T5]) Values() (*T4, *T5) {
	return t.V4, t.V5
}

type Tail3[T4, T5, T6 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
}

func (t Tail3[T4, T5, T6]) Values() (*T4, *T5, *T6) {
	return t.V4, t.V5, t.V6
}

type Tail4[T4, T5, T6, T7 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
}

func (t Tail4[T4, T5, T6, T7]) Values() (*T4, *T5, *T6, *T7) {
	return t.V4, t.V5, t.V6, t.V7
}

type Tail5[T4, T5, T6, T7, T8 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
	V7 *T7
	V8 *T8
}

func (t Tail5[T4, T5, T6, T7, T8]) Values() (*T4, *T5, *T6, *T7, *T8) {
	return t.V4, t.V5, t.V6, t.V7, t.V8
}

// -------------- View1 --------------

type matchedArch1[T1 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
}

type View1[T1 any] struct {
	viewBase
	ids   [1]ComponentID
	baked []matchedArch1[T1]
}

func (v *View1[T1]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch1[T1]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView1[T1 any](reg *Registry) *View1[T1] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	ids := [1]ComponentID{id1}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View1[T1]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View1[T1]) All() iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		var row Head1[T1]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1

			for j := 0; j < len(ents); j++ {

				row.Entity = ents[j]
				row.V1 = &s1[j]
				if !yield(row) {
					return
				}

			}
		}
	}
}

func (v *View1[T1]) Filtered(entities []Entity) iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		var lastArch *Archetype
		var c1 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				lastArch = arch
			}

			idx := backLink.row

			row := Head1[T1]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize))}
			if !yield(row) {
				return
			}

		}
	}
}

// -------------- View2 --------------

type matchedArch2[T1, T2 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
}

type View2[T1, T2 any] struct {
	viewBase
	ids   [2]ComponentID
	baked []matchedArch2[T1, T2]
}

func (v *View2[T1, T2]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch2[T1, T2]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView2[T1, T2 any](reg *Registry) *View2[T1, T2] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	ids := [2]ComponentID{id1, id2}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View2[T1, T2]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View2[T1, T2]) All() iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		var row Head2[T1, T2]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2

			for j := 0; j < len(ents); j++ {

				row.Entity = ents[j]
				row.V1 = &s1[j]
				row.V2 = &s2[j]
				if !yield(row) {
					return
				}

			}
		}
	}
}

func (v *View2[T1, T2]) Filtered(entities []Entity) iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				lastArch = arch
			}

			idx := backLink.row

			row := Head2[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize))}
			if !yield(row) {
				return
			}

		}
	}
}

// -------------- View3 --------------

type matchedArch3[T1, T2, T3 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
}

type View3[T1, T2, T3 any] struct {
	viewBase
	ids   [3]ComponentID
	baked []matchedArch3[T1, T2, T3]
}

func (v *View3[T1, T2, T3]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch3[T1, T2, T3]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView3[T1, T2, T3 any](reg *Registry) *View3[T1, T2, T3] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	ids := [3]ComponentID{id1, id2, id3}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View3[T1, T2, T3]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View3[T1, T2, T3]) All() iter.Seq[Head3[T1, T2, T3]] {
	return func(yield func(Head3[T1, T2, T3]) bool) {
		var row Head3[T1, T2, T3]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3

			for j := 0; j < len(ents); j++ {
				row.Entity = ents[j]
				row.V1 = &s1[j]
				row.V2 = &s2[j]
				row.V3 = &s3[j]
				if !yield(row) {
					return
				}

			}
		}
	}
}

func (v *View3[T1, T2, T3]) Filtered(entities []Entity) iter.Seq[Head3[T1, T2, T3]] {
	return func(yield func(Head3[T1, T2, T3]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				lastArch = arch
			}

			idx := backLink.row

			row := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			if !yield(row) {
				return
			}

		}
	}
}

// -------------- View4 --------------

type matchedArch4[T1, T2, T3, T4 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
	slice4   []T4
}

type View4[T1, T2, T3, T4 any] struct {
	viewBase
	ids   [4]ComponentID
	baked []matchedArch4[T1, T2, T3, T4]
}

func (v *View4[T1, T2, T3, T4]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch4[T1, T2, T3, T4]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		col4 := arch.columns[v.ids[3]]
		mArch.slice4 = unsafe.Slice((*T4)(col4.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView4[T1, T2, T3, T4 any](reg *Registry) *View4[T1, T2, T3, T4] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	ids := [4]ComponentID{id1, id2, id3, id4}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View4[T1, T2, T3, T4]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View4[T1, T2, T3, T4]) All() iter.Seq2[Head3[T1, T2, T3], Tail1[T4]] {
	return func(yield func(Head3[T1, T2, T3], Tail1[T4]) bool) {
		var head Head3[T1, T2, T3]
		var tail Tail1[T4]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3
			s4 := b.slice4

			for j := 0; j < len(ents); j++ {

				head.Entity = ents[j]
				head.V1 = &s1[j]
				head.V2 = &s2[j]
				head.V3 = &s3[j]
				tail.V4 = &s4[j]
				if !yield(head, tail) {
					return
				}

			}
		}
	}
}

func (v *View4[T1, T2, T3, T4]) Filtered(entities []Entity) iter.Seq2[Head3[T1, T2, T3], Tail1[T4]] {
	return func(yield func(Head3[T1, T2, T3], Tail1[T4]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column
		var c4 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				c4 = arch.columns[v.ids[3]]
				lastArch = arch
			}

			idx := backLink.row

			head := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			tail := Tail1[T4]{V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// -------------- View5 --------------

type matchedArch5[T1, T2, T3, T4, T5 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
	slice4   []T4
	slice5   []T5
}

type View5[T1, T2, T3, T4, T5 any] struct {
	viewBase
	ids   [5]ComponentID
	baked []matchedArch5[T1, T2, T3, T4, T5]
}

func (v *View5[T1, T2, T3, T4, T5]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch5[T1, T2, T3, T4, T5]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		col4 := arch.columns[v.ids[3]]
		mArch.slice4 = unsafe.Slice((*T4)(col4.data), arch.len)

		col5 := arch.columns[v.ids[4]]
		mArch.slice5 = unsafe.Slice((*T5)(col5.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView5[T1, T2, T3, T4, T5 any](reg *Registry) *View5[T1, T2, T3, T4, T5] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	ids := [5]ComponentID{id1, id2, id3, id4, id5}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View5[T1, T2, T3, T4, T5]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View5[T1, T2, T3, T4, T5]) All() iter.Seq2[Head3[T1, T2, T3], Tail2[T4, T5]] {
	return func(yield func(Head3[T1, T2, T3], Tail2[T4, T5]) bool) {
		var head Head3[T1, T2, T3]
		var tail Tail2[T4, T5]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3
			s4 := b.slice4
			s5 := b.slice5

			for j := 0; j < len(ents); j++ {

				head.Entity = ents[j]
				head.V1 = &s1[j]
				head.V2 = &s2[j]
				head.V3 = &s3[j]
				tail.V4 = &s4[j]
				tail.V5 = &s5[j]
				if !yield(head, tail) {
					return
				}

			}
		}
	}
}

func (v *View5[T1, T2, T3, T4, T5]) Filtered(entities []Entity) iter.Seq2[Head3[T1, T2, T3], Tail2[T4, T5]] {
	return func(yield func(Head3[T1, T2, T3], Tail2[T4, T5]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column
		var c4 *column
		var c5 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				c4 = arch.columns[v.ids[3]]
				c5 = arch.columns[v.ids[4]]
				lastArch = arch
			}

			idx := backLink.row

			head := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			tail := Tail2[T4, T5]{V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)), V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// -------------- View6 --------------

type matchedArch6[T1, T2, T3, T4, T5, T6 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
	slice4   []T4
	slice5   []T5
	slice6   []T6
}

type View6[T1, T2, T3, T4, T5, T6 any] struct {
	viewBase
	ids   [6]ComponentID
	baked []matchedArch6[T1, T2, T3, T4, T5, T6]
}

func (v *View6[T1, T2, T3, T4, T5, T6]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch6[T1, T2, T3, T4, T5, T6]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		col4 := arch.columns[v.ids[3]]
		mArch.slice4 = unsafe.Slice((*T4)(col4.data), arch.len)

		col5 := arch.columns[v.ids[4]]
		mArch.slice5 = unsafe.Slice((*T5)(col5.data), arch.len)

		col6 := arch.columns[v.ids[5]]
		mArch.slice6 = unsafe.Slice((*T6)(col6.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView6[T1, T2, T3, T4, T5, T6 any](reg *Registry) *View6[T1, T2, T3, T4, T5, T6] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	ids := [6]ComponentID{id1, id2, id3, id4, id5, id6}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View6[T1, T2, T3, T4, T5, T6]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View6[T1, T2, T3, T4, T5, T6]) All() iter.Seq2[Head3[T1, T2, T3], Tail3[T4, T5, T6]] {
	return func(yield func(Head3[T1, T2, T3], Tail3[T4, T5, T6]) bool) {
		var head Head3[T1, T2, T3]
		var tail Tail3[T4, T5, T6]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3
			s4 := b.slice4
			s5 := b.slice5
			s6 := b.slice6

			for j := 0; j < len(ents); j++ {

				head.Entity = ents[j]
				head.V1 = &s1[j]
				head.V2 = &s2[j]
				head.V3 = &s3[j]
				tail.V4 = &s4[j]
				tail.V5 = &s5[j]
				tail.V6 = &s6[j]
				if !yield(head, tail) {
					return
				}

			}
		}
	}
}

func (v *View6[T1, T2, T3, T4, T5, T6]) Filtered(entities []Entity) iter.Seq2[Head3[T1, T2, T3], Tail3[T4, T5, T6]] {
	return func(yield func(Head3[T1, T2, T3], Tail3[T4, T5, T6]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column
		var c4 *column
		var c5 *column
		var c6 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				c4 = arch.columns[v.ids[3]]
				c5 = arch.columns[v.ids[4]]
				c6 = arch.columns[v.ids[5]]
				lastArch = arch
			}

			idx := backLink.row

			head := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			tail := Tail3[T4, T5, T6]{V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)), V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize)), V6: (*T6)(unsafe.Add(c6.data, uintptr(idx)*c6.itemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// -------------- View7 --------------

type matchedArch7[T1, T2, T3, T4, T5, T6, T7 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
	slice4   []T4
	slice5   []T5
	slice6   []T6
	slice7   []T7
}

type View7[T1, T2, T3, T4, T5, T6, T7 any] struct {
	viewBase
	ids   [7]ComponentID
	baked []matchedArch7[T1, T2, T3, T4, T5, T6, T7]
}

func (v *View7[T1, T2, T3, T4, T5, T6, T7]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch7[T1, T2, T3, T4, T5, T6, T7]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		col4 := arch.columns[v.ids[3]]
		mArch.slice4 = unsafe.Slice((*T4)(col4.data), arch.len)

		col5 := arch.columns[v.ids[4]]
		mArch.slice5 = unsafe.Slice((*T5)(col5.data), arch.len)

		col6 := arch.columns[v.ids[5]]
		mArch.slice6 = unsafe.Slice((*T6)(col6.data), arch.len)

		col7 := arch.columns[v.ids[6]]
		mArch.slice7 = unsafe.Slice((*T7)(col7.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView7[T1, T2, T3, T4, T5, T6, T7 any](reg *Registry) *View7[T1, T2, T3, T4, T5, T6, T7] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	id7 := ensureComponentRegistered[T7](reg.componentsRegistry)
	ids := [7]ComponentID{id1, id2, id3, id4, id5, id6, id7}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View7[T1, T2, T3, T4, T5, T6, T7]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View7[T1, T2, T3, T4, T5, T6, T7]) All() iter.Seq2[Head3[T1, T2, T3], Tail4[T4, T5, T6, T7]] {
	return func(yield func(Head3[T1, T2, T3], Tail4[T4, T5, T6, T7]) bool) {
		var head Head3[T1, T2, T3]
		var tail Tail4[T4, T5, T6, T7]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3
			s4 := b.slice4
			s5 := b.slice5
			s6 := b.slice6
			s7 := b.slice7

			for j := 0; j < len(ents); j++ {

				head.Entity = ents[j]
				head.V1 = &s1[j]
				head.V2 = &s2[j]
				head.V3 = &s3[j]
				tail.V4 = &s4[j]
				tail.V5 = &s5[j]
				tail.V6 = &s6[j]
				tail.V7 = &s7[j]
				if !yield(head, tail) {
					return
				}

			}
		}
	}
}

func (v *View7[T1, T2, T3, T4, T5, T6, T7]) Filtered(entities []Entity) iter.Seq2[Head3[T1, T2, T3], Tail4[T4, T5, T6, T7]] {
	return func(yield func(Head3[T1, T2, T3], Tail4[T4, T5, T6, T7]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column
		var c4 *column
		var c5 *column
		var c6 *column
		var c7 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				c4 = arch.columns[v.ids[3]]
				c5 = arch.columns[v.ids[4]]
				c6 = arch.columns[v.ids[5]]
				c7 = arch.columns[v.ids[6]]
				lastArch = arch
			}

			idx := backLink.row

			head := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			tail := Tail4[T4, T5, T6, T7]{V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)), V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize)), V6: (*T6)(unsafe.Add(c6.data, uintptr(idx)*c6.itemSize)), V7: (*T7)(unsafe.Add(c7.data, uintptr(idx)*c7.itemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}

// -------------- View8 --------------

type matchedArch8[T1, T2, T3, T4, T5, T6, T7, T8 any] struct {
	arch     *Archetype
	entities []Entity
	slice1   []T1
	slice2   []T2
	slice3   []T3
	slice4   []T4
	slice5   []T5
	slice6   []T6
	slice7   []T7
	slice8   []T8
}

type View8[T1, T2, T3, T4, T5, T6, T7, T8 any] struct {
	viewBase
	ids   [8]ComponentID
	baked []matchedArch8[T1, T2, T3, T4, T5, T6, T7, T8]
}

func (v *View8[T1, T2, T3, T4, T5, T6, T7, T8]) Reindex() {
	v.viewBase.Reindex()
	v.baked = v.baked[:0]
	for _, arch := range v.matched {
		if arch.len == 0 {
			continue
		}
		mArch := matchedArch8[T1, T2, T3, T4, T5, T6, T7, T8]{
			arch:     arch,
			entities: arch.entities[:arch.len],
		}

		col1 := arch.columns[v.ids[0]]
		mArch.slice1 = unsafe.Slice((*T1)(col1.data), arch.len)

		col2 := arch.columns[v.ids[1]]
		mArch.slice2 = unsafe.Slice((*T2)(col2.data), arch.len)

		col3 := arch.columns[v.ids[2]]
		mArch.slice3 = unsafe.Slice((*T3)(col3.data), arch.len)

		col4 := arch.columns[v.ids[3]]
		mArch.slice4 = unsafe.Slice((*T4)(col4.data), arch.len)

		col5 := arch.columns[v.ids[4]]
		mArch.slice5 = unsafe.Slice((*T5)(col5.data), arch.len)

		col6 := arch.columns[v.ids[5]]
		mArch.slice6 = unsafe.Slice((*T6)(col6.data), arch.len)

		col7 := arch.columns[v.ids[6]]
		mArch.slice7 = unsafe.Slice((*T7)(col7.data), arch.len)

		col8 := arch.columns[v.ids[7]]
		mArch.slice8 = unsafe.Slice((*T8)(col8.data), arch.len)

		v.baked = append(v.baked, mArch)
	}
}

func NewView8[T1, T2, T3, T4, T5, T6, T7, T8 any](reg *Registry) *View8[T1, T2, T3, T4, T5, T6, T7, T8] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	id7 := ensureComponentRegistered[T7](reg.componentsRegistry)
	id8 := ensureComponentRegistered[T8](reg.componentsRegistry)
	ids := [8]ComponentID{id1, id2, id3, id4, id5, id6, id7, id8}

	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View8[T1, T2, T3, T4, T5, T6, T7, T8]{
		viewBase: viewBase{
			reg:             reg,
			mask:            mask,
			entityArchLinks: reg.archetypeRegistry.entityArchLinks,
		},
		ids: ids,
	}
	v.Reindex()
	return v
}

func (v *View8[T1, T2, T3, T4, T5, T6, T7, T8]) All() iter.Seq2[Head3[T1, T2, T3], Tail5[T4, T5, T6, T7, T8]] {
	return func(yield func(Head3[T1, T2, T3], Tail5[T4, T5, T6, T7, T8]) bool) {
		var head Head3[T1, T2, T3]
		var tail Tail5[T4, T5, T6, T7, T8]

		for i := range v.baked {
			b := &v.baked[i]
			ents := b.entities
			s1 := b.slice1
			s2 := b.slice2
			s3 := b.slice3
			s4 := b.slice4
			s5 := b.slice5
			s6 := b.slice6
			s7 := b.slice7
			s8 := b.slice8

			for j := 0; j < len(ents); j++ {

				head.Entity = ents[j]
				head.V1 = &s1[j]
				head.V2 = &s2[j]
				head.V3 = &s3[j]
				tail.V4 = &s4[j]
				tail.V5 = &s5[j]
				tail.V6 = &s6[j]
				tail.V7 = &s7[j]
				tail.V8 = &s8[j]
				if !yield(head, tail) {
					return
				}

			}
		}
	}
}

func (v *View8[T1, T2, T3, T4, T5, T6, T7, T8]) Filtered(entities []Entity) iter.Seq2[Head3[T1, T2, T3], Tail5[T4, T5, T6, T7, T8]] {
	return func(yield func(Head3[T1, T2, T3], Tail5[T4, T5, T6, T7, T8]) bool) {
		var lastArch *Archetype
		var c1 *column
		var c2 *column
		var c3 *column
		var c4 *column
		var c5 *column
		var c6 *column
		var c7 *column
		var c8 *column

		for _, e := range entities {
			backLink := v.viewBase.entityArchLinks[e.Index()]
			arch := backLink.arch
			if arch == nil || !arch.mask.Contains(v.mask) {
				continue
			}

			if arch != lastArch {
				c1 = arch.columns[v.ids[0]]
				c2 = arch.columns[v.ids[1]]
				c3 = arch.columns[v.ids[2]]
				c4 = arch.columns[v.ids[3]]
				c5 = arch.columns[v.ids[4]]
				c6 = arch.columns[v.ids[5]]
				c7 = arch.columns[v.ids[6]]
				c8 = arch.columns[v.ids[7]]
				lastArch = arch
			}

			idx := backLink.row

			head := Head3[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)), V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)), V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize))}
			tail := Tail5[T4, T5, T6, T7, T8]{V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)), V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize)), V6: (*T6)(unsafe.Add(c6.data, uintptr(idx)*c6.itemSize)), V7: (*T7)(unsafe.Add(c7.data, uintptr(idx)*c7.itemSize)), V8: (*T8)(unsafe.Add(c8.data, uintptr(idx)*c8.itemSize))}
			if !yield(head, tail) {
				return
			}

		}
	}
}
