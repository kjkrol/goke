// Code generated by go generate; DO NOT EDIT.
package ecs

import (
	"iter"
	"unsafe"
)


// -------------- View1 --------------

type View1[T1 any] struct {
	viewBase
	ids [1]ComponentID
}

type Row1[T1 any] struct {
	V1 *T1
}

func (r Row1[T1]) Values() (*T1) {
	return r.V1
}

func NewView1[T1 any](reg *Registry) *View1[T1] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	ids := [1]ComponentID{ id1 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View1[T1]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View1[T1]) All() iter.Seq2[Entity, Row1[T1]] {
	return func(yield func(Entity, Row1[T1]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row1[T1]{ V1: (*T1)(ptr1) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
			}
		}
	}
}

func (v *View1[T1]) Filtered(entities []Entity) iter.Seq2[Entity, Row1[T1]] {
    return func(yield func(Entity, Row1[T1]) bool) {
        var lastArch *archetype
        
        var c1 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row1[T1]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}


// -------------- View2 --------------

type View2[T1 any, T2 any] struct {
	viewBase
	ids [2]ComponentID
}

type Row2[T1 any, T2 any] struct {
	V1 *T1; V2 *T2
}

func (r Row2[T1, T2]) Values() (*T1, *T2) {
	return r.V1, r.V2
}

func NewView2[T1 any, T2 any](reg *Registry) *View2[T1, T2] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	ids := [2]ComponentID{ id1, id2 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View2[T1, T2]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View2[T1, T2]) All() iter.Seq2[Entity, Row2[T1, T2]] {
	return func(yield func(Entity, Row2[T1, T2]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			
			col2 := arch.columns[v.ids[1]]
			ptr2 := col2.data
			size2 := uintptr(col2.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row2[T1, T2]{ V1: (*T1)(ptr1), V2: (*T2)(ptr2) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
			}
		}
	}
}

func (v *View2[T1, T2]) Filtered(entities []Entity) iter.Seq2[Entity, Row2[T1, T2]] {
    return func(yield func(Entity, Row2[T1, T2]) bool) {
        var lastArch *archetype
        
        var c1 *column
        
        var c2 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                c2 = arch.columns[v.ids[1]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row2[T1, T2]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
                V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}


// -------------- View3 --------------

type View3[T1 any, T2 any, T3 any] struct {
	viewBase
	ids [3]ComponentID
}

type Row3[T1 any, T2 any, T3 any] struct {
	V1 *T1; V2 *T2; V3 *T3
}

func (r Row3[T1, T2, T3]) Values() (*T1, *T2, *T3) {
	return r.V1, r.V2, r.V3
}

func NewView3[T1 any, T2 any, T3 any](reg *Registry) *View3[T1, T2, T3] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	ids := [3]ComponentID{ id1, id2, id3 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View3[T1, T2, T3]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View3[T1, T2, T3]) All() iter.Seq2[Entity, Row3[T1, T2, T3]] {
	return func(yield func(Entity, Row3[T1, T2, T3]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			
			col2 := arch.columns[v.ids[1]]
			ptr2 := col2.data
			size2 := uintptr(col2.itemSize)
			
			col3 := arch.columns[v.ids[2]]
			ptr3 := col3.data
			size3 := uintptr(col3.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row3[T1, T2, T3]{ V1: (*T1)(ptr1), V2: (*T2)(ptr2), V3: (*T3)(ptr3) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
			}
		}
	}
}

func (v *View3[T1, T2, T3]) Filtered(entities []Entity) iter.Seq2[Entity, Row3[T1, T2, T3]] {
    return func(yield func(Entity, Row3[T1, T2, T3]) bool) {
        var lastArch *archetype
        
        var c1 *column
        
        var c2 *column
        
        var c3 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                c2 = arch.columns[v.ids[1]]
                
                c3 = arch.columns[v.ids[2]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row3[T1, T2, T3]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
                V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)),
                
                V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}


// -------------- View4 --------------

type View4[T1 any, T2 any, T3 any, T4 any] struct {
	viewBase
	ids [4]ComponentID
}

type Row4[T1 any, T2 any, T3 any, T4 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4
}

func (r Row4[T1, T2, T3, T4]) Values() (*T1, *T2, *T3, *T4) {
	return r.V1, r.V2, r.V3, r.V4
}

func NewView4[T1 any, T2 any, T3 any, T4 any](reg *Registry) *View4[T1, T2, T3, T4] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	ids := [4]ComponentID{ id1, id2, id3, id4 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View4[T1, T2, T3, T4]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View4[T1, T2, T3, T4]) All() iter.Seq2[Entity, Row4[T1, T2, T3, T4]] {
	return func(yield func(Entity, Row4[T1, T2, T3, T4]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			
			col2 := arch.columns[v.ids[1]]
			ptr2 := col2.data
			size2 := uintptr(col2.itemSize)
			
			col3 := arch.columns[v.ids[2]]
			ptr3 := col3.data
			size3 := uintptr(col3.itemSize)
			
			col4 := arch.columns[v.ids[3]]
			ptr4 := col4.data
			size4 := uintptr(col4.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row4[T1, T2, T3, T4]{ V1: (*T1)(ptr1), V2: (*T2)(ptr2), V3: (*T3)(ptr3), V4: (*T4)(ptr4) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
			}
		}
	}
}

func (v *View4[T1, T2, T3, T4]) Filtered(entities []Entity) iter.Seq2[Entity, Row4[T1, T2, T3, T4]] {
    return func(yield func(Entity, Row4[T1, T2, T3, T4]) bool) {
        var lastArch *archetype
        
        var c1 *column
        
        var c2 *column
        
        var c3 *column
        
        var c4 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                c2 = arch.columns[v.ids[1]]
                
                c3 = arch.columns[v.ids[2]]
                
                c4 = arch.columns[v.ids[3]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row4[T1, T2, T3, T4]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
                V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)),
                
                V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize)),
                
                V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}


// -------------- View5 --------------

type View5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	viewBase
	ids [5]ComponentID
}

type Row5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4; V5 *T5
}

func (r Row5[T1, T2, T3, T4, T5]) Values() (*T1, *T2, *T3, *T4, *T5) {
	return r.V1, r.V2, r.V3, r.V4, r.V5
}

func NewView5[T1 any, T2 any, T3 any, T4 any, T5 any](reg *Registry) *View5[T1, T2, T3, T4, T5] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	ids := [5]ComponentID{ id1, id2, id3, id4, id5 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View5[T1, T2, T3, T4, T5]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View5[T1, T2, T3, T4, T5]) All() iter.Seq2[Entity, Row5[T1, T2, T3, T4, T5]] {
	return func(yield func(Entity, Row5[T1, T2, T3, T4, T5]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			
			col2 := arch.columns[v.ids[1]]
			ptr2 := col2.data
			size2 := uintptr(col2.itemSize)
			
			col3 := arch.columns[v.ids[2]]
			ptr3 := col3.data
			size3 := uintptr(col3.itemSize)
			
			col4 := arch.columns[v.ids[3]]
			ptr4 := col4.data
			size4 := uintptr(col4.itemSize)
			
			col5 := arch.columns[v.ids[4]]
			ptr5 := col5.data
			size5 := uintptr(col5.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row5[T1, T2, T3, T4, T5]{ V1: (*T1)(ptr1), V2: (*T2)(ptr2), V3: (*T3)(ptr3), V4: (*T4)(ptr4), V5: (*T5)(ptr5) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
				ptr5 = unsafe.Add(ptr5, size5)
			}
		}
	}
}

func (v *View5[T1, T2, T3, T4, T5]) Filtered(entities []Entity) iter.Seq2[Entity, Row5[T1, T2, T3, T4, T5]] {
    return func(yield func(Entity, Row5[T1, T2, T3, T4, T5]) bool) {
        var lastArch *archetype
        
        var c1 *column
        
        var c2 *column
        
        var c3 *column
        
        var c4 *column
        
        var c5 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                c2 = arch.columns[v.ids[1]]
                
                c3 = arch.columns[v.ids[2]]
                
                c4 = arch.columns[v.ids[3]]
                
                c5 = arch.columns[v.ids[4]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row5[T1, T2, T3, T4, T5]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
                V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)),
                
                V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize)),
                
                V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)),
                
                V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}


// -------------- View6 --------------

type View6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	viewBase
	ids [6]ComponentID
}

type Row6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any] struct {
	V1 *T1; V2 *T2; V3 *T3; V4 *T4; V5 *T5; V6 *T6
}

func (r Row6[T1, T2, T3, T4, T5, T6]) Values() (*T1, *T2, *T3, *T4, *T5, *T6) {
	return r.V1, r.V2, r.V3, r.V4, r.V5, r.V6
}

func NewView6[T1 any, T2 any, T3 any, T4 any, T5 any, T6 any](reg *Registry) *View6[T1, T2, T3, T4, T5, T6] {
	id1 := ensureComponentRegistered[T1](reg.componentsRegistry)
	id2 := ensureComponentRegistered[T2](reg.componentsRegistry)
	id3 := ensureComponentRegistered[T3](reg.componentsRegistry)
	id4 := ensureComponentRegistered[T4](reg.componentsRegistry)
	id5 := ensureComponentRegistered[T5](reg.componentsRegistry)
	id6 := ensureComponentRegistered[T6](reg.componentsRegistry)
	ids := [6]ComponentID{ id1, id2, id3, id4, id5, id6 }
	
	var mask ArchetypeMask
	for _, id := range ids {
		mask = mask.Set(id)
	}

	v := &View6[T1, T2, T3, T4, T5, T6]{
		viewBase: viewBase{
			reg:  reg,
			mask: mask,
		},
		ids: ids,
	}
	
	v.Reindex() 
	return v
}

func (v *View6[T1, T2, T3, T4, T5, T6]) All() iter.Seq2[Entity, Row6[T1, T2, T3, T4, T5, T6]] {
	return func(yield func(Entity, Row6[T1, T2, T3, T4, T5, T6]) bool) {
		for _, arch := range v.matched {
			if arch.len == 0 {
				continue
			}

			
			col1 := arch.columns[v.ids[0]]
			ptr1 := col1.data
			size1 := uintptr(col1.itemSize)
			
			col2 := arch.columns[v.ids[1]]
			ptr2 := col2.data
			size2 := uintptr(col2.itemSize)
			
			col3 := arch.columns[v.ids[2]]
			ptr3 := col3.data
			size3 := uintptr(col3.itemSize)
			
			col4 := arch.columns[v.ids[3]]
			ptr4 := col4.data
			size4 := uintptr(col4.itemSize)
			
			col5 := arch.columns[v.ids[4]]
			ptr5 := col5.data
			size5 := uintptr(col5.itemSize)
			
			col6 := arch.columns[v.ids[5]]
			ptr6 := col6.data
			size6 := uintptr(col6.itemSize)
			

			for i := 0; i < arch.len; i++ {
				if !yield(arch.entities[i], Row6[T1, T2, T3, T4, T5, T6]{ V1: (*T1)(ptr1), V2: (*T2)(ptr2), V3: (*T3)(ptr3), V4: (*T4)(ptr4), V5: (*T5)(ptr5), V6: (*T6)(ptr6) }) {
					return
				}
				ptr1 = unsafe.Add(ptr1, size1)
				ptr2 = unsafe.Add(ptr2, size2)
				ptr3 = unsafe.Add(ptr3, size3)
				ptr4 = unsafe.Add(ptr4, size4)
				ptr5 = unsafe.Add(ptr5, size5)
				ptr6 = unsafe.Add(ptr6, size6)
			}
		}
	}
}

func (v *View6[T1, T2, T3, T4, T5, T6]) Filtered(entities []Entity) iter.Seq2[Entity, Row6[T1, T2, T3, T4, T5, T6]] {
    return func(yield func(Entity, Row6[T1, T2, T3, T4, T5, T6]) bool) {
        var lastArch *archetype
        
        var c1 *column
        
        var c2 *column
        
        var c3 *column
        
        var c4 *column
        
        var c5 *column
        
        var c6 *column
        

        for _, e := range entities {
            rec, ok := v.reg.entitiesRegistry.GetRecord(e)
            if !ok {
                continue
            }

            arch := rec.arch
            if arch == nil || !arch.mask.Contains(v.mask) {
                continue
            }

            if arch != lastArch {
                
                c1 = arch.columns[v.ids[0]]
                
                c2 = arch.columns[v.ids[1]]
                
                c3 = arch.columns[v.ids[2]]
                
                c4 = arch.columns[v.ids[3]]
                
                c5 = arch.columns[v.ids[4]]
                
                c6 = arch.columns[v.ids[5]]
                
                lastArch = arch
            }

            idx := rec.index
            row := Row6[T1, T2, T3, T4, T5, T6]{
                
                V1: (*T1)(unsafe.Add(c1.data, uintptr(idx)*c1.itemSize)),
                
                V2: (*T2)(unsafe.Add(c2.data, uintptr(idx)*c2.itemSize)),
                
                V3: (*T3)(unsafe.Add(c3.data, uintptr(idx)*c3.itemSize)),
                
                V4: (*T4)(unsafe.Add(c4.data, uintptr(idx)*c4.itemSize)),
                
                V5: (*T5)(unsafe.Add(c5.data, uintptr(idx)*c5.itemSize)),
                
                V6: (*T6)(unsafe.Add(c6.data, uintptr(idx)*c6.itemSize)),
                
            }

            if !yield(e, row) {
                return
            }
        }
    }
}

