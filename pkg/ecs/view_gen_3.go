// Code generated by gen/views; DO NOT EDIT.
package ecs

import (
	"github.com/kjkrol/goke/internal/core"
	"iter"
	"unsafe"
)

type View3[T1, T2, T3 any] struct {
	*core.View
}

func NewView3[T1, T2, T3 any](eng *Engine, options ...ViewOption) *View3[T1, T2, T3] {
	viewBuilder := core.NewViewBuilder(eng.registry)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	core.OnCompType[T3](viewBuilder)

	for _, opt := range options {
		opt(viewBuilder)
	}
	return &View3[T1, T2, T3]{View: viewBuilder.Build()}
}

// --- Head/Tail ---

type Head3[T1, T2, T3 any] struct {
	Entity Entity
	V1     *T1
	V2     *T2
	V3     *T3
}

type VHead3[T1, T2, T3 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
}

// --- All / Filter ---

func (q *View3[T1, T2, T3]) All() iter.Seq[Head3[T1, T2, T3]] {
	return func(yield func(Head3[T1, T2, T3]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize

			for j := 0; j < *b.Len; j++ {
				head := Head3[T1, T2, T3]{
					Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3),
				}

				if !yield(head) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)

			}
		}
	}
}

func (q *View3[T1, T2, T3]) Filter(selected []Entity) iter.Seq[Head3[T1, T2, T3]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(Head3[T1, T2, T3]) bool) {
		var lastArch *core.Archetype
		var cols [3]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 3; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head3[T1, T2, T3]{
				Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize)),
			}

			if !yield(head) {
				return
			}

		}
	}
}

// --- Values / FilterValues ---

func (q *View3[T1, T2, T3]) Values() iter.Seq[VHead3[T1, T2, T3]] {
	return func(yield func(VHead3[T1, T2, T3]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			p3, s3 := b.Columns[2].Data, b.Columns[2].ItemSize

			for j := 0; j < *b.Len; j++ {
				vhead := VHead3[T1, T2, T3]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}

				if !yield(vhead) {
					return
				}

				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)

			}
		}
	}
}

func (q *View3[T1, T2, T3]) FilterValues(selected []Entity) iter.Seq[VHead3[T1, T2, T3]] {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func(VHead3[T1, T2, T3]) bool) {
		var lastArch *core.Archetype
		var cols [3]*core.Column
		for _, e := range selected {
			link := links.Get(e.Index())
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) {
				continue
			}
			if arch != lastArch {
				for i := 0; i < 3; i++ {
					cols[i] = arch.Columns[q.CompIDs[i]]
				}
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead3[T1, T2, T3]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize)), V3: (*T3)(unsafe.Add(cols[2].Data, idx*cols[2].ItemSize))}

			if !yield(vhead) {
				return
			}

		}
	}
}
