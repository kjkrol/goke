// Code generated by ecs/gen; DO NOT EDIT.
package ecs
import (
	"iter"
	"unsafe"
)

type Query6[T1, T2, T3, T4, T5, T6 any] struct {
	*View
}

func NewQuery6[T1, T2, T3, T4, T5, T6 any](reg *Registry) *Query6[T1, T2, T3, T4, T5, T6] {
	viewBuilder := NewViewBuilder(reg)
	id1 := ensureComponentRegistered[T1](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id1)
	id2 := ensureComponentRegistered[T2](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id2)
	id3 := ensureComponentRegistered[T3](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id3)
	id4 := ensureComponentRegistered[T4](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id4)
	id5 := ensureComponentRegistered[T5](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id5)
	id6 := ensureComponentRegistered[T6](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id6)
	return &Query6[T1, T2, T3, T4, T5, T6]{View: viewBuilder.Build()}
}

type Head6[T1, T2, T3 any] struct {
	Entity Entity
	V1 *T1
	V2 *T2
	V3 *T3
}
type Tail6[T4, T5, T6 any] struct {
	V4 *T4
	V5 *T5
	V6 *T6
}
type PHead6[T1, T2, T3, T4 any] struct {
	V1 *T1
	V2 *T2
	V3 *T3
	V4 *T4
}
type PTail6[T5, T6 any] struct {
	V5 *T5
	V6 *T6
}

func (q *Query6[T1, T2, T3, T4, T5, T6]) All6() iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		for i := range q.baked {
			b := &q.baked[i]
			p1, s1 := b.columns[0].data, b.columns[0].itemSize
			p2, s2 := b.columns[1].data, b.columns[1].itemSize
			p3, s3 := b.columns[2].data, b.columns[2].itemSize
			p4, s4 := b.columns[3].data, b.columns[3].itemSize
			p5, s5 := b.columns[4].data, b.columns[4].itemSize
			p6, s6 := b.columns[5].data, b.columns[5].itemSize
			for j := 0; j < *b.len; j++ {
				if !yield(Head6[T1, T2, T3]{Entity: (*b.entities)[j], V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3)}, Tail6[T4, T5, T6]{V4: (*T4)(p4), V5: (*T5)(p5), V6: (*T6)(p6)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
			}
		}
	}
}

func (q *Query6[T1, T2, T3, T4, T5, T6]) Filter6(entities []Entity) iter.Seq2[Head6[T1, T2, T3], Tail6[T4, T5, T6]] {
	links := q.reg.archetypeRegistry.entityArchLinks
	return func(yield func(Head6[T1, T2, T3], Tail6[T4, T5, T6]) bool) {
		var lastArch *Archetype; var cols [6]*column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(q.mask) { continue }
			if arch != lastArch { for i := 0; i < 6; i++ { cols[i] = arch.columns[q.compIDs[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head6[T1, T2, T3]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize)), V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize))}, Tail6[T4, T5, T6]{V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize)), V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize)), V6: (*T6)(unsafe.Add(cols[5].data, idx*cols[5].itemSize))}) { return }
		}
	}
}

func (q *Query6[T1, T2, T3, T4, T5, T6]) PureAll6() iter.Seq2[PHead6[T1, T2, T3, T4], PTail6[T5, T6]] {
	return func(yield func(PHead6[T1, T2, T3, T4], PTail6[T5, T6]) bool) {
		for i := range q.baked {
			b := &q.baked[i]
			p1, s1 := b.columns[0].data, b.columns[0].itemSize
			p2, s2 := b.columns[1].data, b.columns[1].itemSize
			p3, s3 := b.columns[2].data, b.columns[2].itemSize
			p4, s4 := b.columns[3].data, b.columns[3].itemSize
			p5, s5 := b.columns[4].data, b.columns[4].itemSize
			p6, s6 := b.columns[5].data, b.columns[5].itemSize
			for j := 0; j < *b.len; j++ {
				if !yield(PHead6[T1, T2, T3, T4]{V1: (*T1)(p1), V2: (*T2)(p2), V3: (*T3)(p3), V4: (*T4)(p4)}, PTail6[T5, T6]{V5: (*T5)(p5), V6: (*T6)(p6)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
				p3 = unsafe.Add(p3, s3)
				p4 = unsafe.Add(p4, s4)
				p5 = unsafe.Add(p5, s5)
				p6 = unsafe.Add(p6, s6)
			}
		}
	}
}

func (q *Query6[T1, T2, T3, T4, T5, T6]) PureFilter6(entities []Entity) iter.Seq2[PHead6[T1, T2, T3, T4], PTail6[T5, T6]] {
	links := q.reg.archetypeRegistry.entityArchLinks
	return func(yield func(PHead6[T1, T2, T3, T4], PTail6[T5, T6]) bool) {
		var lastArch *Archetype; var cols [6]*column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(q.mask) { continue }
			if arch != lastArch { for i := 0; i < 6; i++ { cols[i] = arch.columns[q.compIDs[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(PHead6[T1, T2, T3, T4]{V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize)), V2: (*T2)(unsafe.Add(cols[1].data, idx*cols[1].itemSize)), V3: (*T3)(unsafe.Add(cols[2].data, idx*cols[2].itemSize)), V4: (*T4)(unsafe.Add(cols[3].data, idx*cols[3].itemSize))}, PTail6[T5, T6]{V5: (*T5)(unsafe.Add(cols[4].data, idx*cols[4].itemSize)), V6: (*T6)(unsafe.Add(cols[5].data, idx*cols[5].itemSize))}) { return }
		}
	}
}
