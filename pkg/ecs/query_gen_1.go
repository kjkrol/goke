// Code generated by ecs/gen; DO NOT EDIT.
package ecs
import (
	"iter"
	"unsafe"
)

type Query1[T1 any] struct {
	*View
}

func NewQuery1[T1 any](reg *Registry) *Query1[T1] {
	viewBuilder := NewViewBuilder(reg)
	id1 := ensureComponentRegistered[T1](viewBuilder.reg.componentsRegistry)
	viewBuilder.OnType(id1)
	return &Query1[T1]{View: viewBuilder.Build()}
}

type Head1[T1 any] struct {
	Entity Entity
	V1 *T1
}
type PHead1[T1 any] struct {
	V1 *T1
}

func (q *Query1[T1]) All1() iter.Seq[Head1[T1]] {
	return func(yield func(Head1[T1]) bool) {
		for i := range q.baked {
			b := &q.baked[i]
			p1, s1 := b.columns[0].data, b.columns[0].itemSize
			for j := 0; j < *b.len; j++ {
				if !yield(Head1[T1]{Entity: (*b.entities)[j], V1: (*T1)(p1)}) { return }
				p1 = unsafe.Add(p1, s1)
			}
		}
	}
}

func (q *Query1[T1]) Filter1(entities []Entity) iter.Seq[Head1[T1]] {
	links := q.reg.archetypeRegistry.entityArchLinks
	return func(yield func(Head1[T1]) bool) {
		var lastArch *Archetype; var cols [1]*column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(q.mask) { continue }
			if arch != lastArch { for i := 0; i < 1; i++ { cols[i] = arch.columns[q.compIDs[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(Head1[T1]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize))}) { return }
		}
	}
}

func (q *Query1[T1]) PureAll1() iter.Seq[PHead1[T1]] {
	return func(yield func(PHead1[T1]) bool) {
		for i := range q.baked {
			b := &q.baked[i]
			p1, s1 := b.columns[0].data, b.columns[0].itemSize
			for j := 0; j < *b.len; j++ {
				if !yield(PHead1[T1]{V1: (*T1)(p1)}) { return }
				p1 = unsafe.Add(p1, s1)
			}
		}
	}
}

func (q *Query1[T1]) PureFilter1(entities []Entity) iter.Seq[PHead1[T1]] {
	links := q.reg.archetypeRegistry.entityArchLinks
	return func(yield func(PHead1[T1]) bool) {
		var lastArch *Archetype; var cols [1]*column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.arch
			if arch == nil || !arch.mask.Contains(q.mask) { continue }
			if arch != lastArch { for i := 0; i < 1; i++ { cols[i] = arch.columns[q.compIDs[i]] }; lastArch = arch }
			idx := uintptr(link.row)
			if !yield(PHead1[T1]{V1: (*T1)(unsafe.Add(cols[0].data, idx*cols[0].itemSize))}) { return }
		}
	}
}
