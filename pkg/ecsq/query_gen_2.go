// Code generated by gen/queries; DO NOT EDIT.
package ecsq
import (
	"iter"
	"unsafe"

	"github.com/kjkrol/goke/internal/core"
)

type Query2[T1, T2 any] struct {
	*core.View
}

func NewQuery2[T1, T2 any](reg *core.Registry, options ...core.ViewOption) *Query2[T1, T2] {
	viewBuilder := core.NewViewBuilder(reg)
	core.OnCompType[T1](viewBuilder)
	core.OnCompType[T2](viewBuilder)
	for _, opt := range options {
		opt(viewBuilder)
	}
	return &Query2[T1, T2]{View: viewBuilder.Build()}
}

type Head2[T1, T2 any] struct {
	Entity core.Entity
	V1 *T1
	V2 *T2
}
type PHead2[T1, T2 any] struct {
	V1 *T1
	V2 *T2
}

func (q *Query2[T1, T2]) All2() iter.Seq[Head2[T1, T2]] {
	return func(yield func(Head2[T1, T2]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			for j := 0; j < *b.Len; j++ {
				if !yield(Head2[T1, T2]{Entity: (*b.Entities)[j], V1: (*T1)(p1), V2: (*T2)(p2)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
			}
		}
	}
}

func (q *Query2[T1, T2]) Filter2(entities []core.Entity) iter.Seq[Head2[T1, T2]] {
	links := q.Reg.ArchetypeRegistry.EntityArchLinks
	return func(yield func(Head2[T1, T2]) bool) {
		var lastArch *core.Archetype; var cols [2]*core.Column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.Arch
			if arch == nil || q.View.Matches(arch.Mask) { continue }
			if arch != lastArch { for i := 0; i < 2; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }
			idx := uintptr(link.Row)
			if !yield(Head2[T1, T2]{Entity: e, V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize))}) { return }
		}
	}
}

func (q *Query2[T1, T2]) PureAll2() iter.Seq[PHead2[T1, T2]] {
	return func(yield func(PHead2[T1, T2]) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			p1, s1 := b.Columns[0].Data, b.Columns[0].ItemSize
			p2, s2 := b.Columns[1].Data, b.Columns[1].ItemSize
			for j := 0; j < *b.Len; j++ {
				if !yield(PHead2[T1, T2]{V1: (*T1)(p1), V2: (*T2)(p2)}) { return }
				p1 = unsafe.Add(p1, s1)
				p2 = unsafe.Add(p2, s2)
			}
		}
	}
}

func (q *Query2[T1, T2]) PureFilter2(entities []core.Entity) iter.Seq[PHead2[T1, T2]] {
	links := q.Reg.ArchetypeRegistry.EntityArchLinks
	return func(yield func(PHead2[T1, T2]) bool) {
		var lastArch *core.Archetype; var cols [2]*core.Column
		for _, e := range entities {
			link := links[e.Index()]; arch := link.Arch
			if arch == nil || q.View.Matches(arch.Mask) { continue }
			if arch != lastArch { for i := 0; i < 2; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }
			idx := uintptr(link.Row)
			if !yield(PHead2[T1, T2]{V1: (*T1)(unsafe.Add(cols[0].Data, idx*cols[0].ItemSize)), V2: (*T2)(unsafe.Add(cols[1].Data, idx*cols[1].ItemSize))}) { return }
		}
	}
}
