package main

import (
	"fmt"
	"os"
	"strings"
)

const MaxComponents = 8

type Fn func(*os.File, int)

func main() {
	for i := 1; i <= MaxComponents; i++ {
		fileName := fmt.Sprintf("query_gen_%d.go", i)
		file, err := os.Create(fileName)
		if err != nil {
			panic(err)
		}

		fmt.Fprintln(file, "// Code generated by gen/queries; DO NOT EDIT.")
		fmt.Fprintln(file, "package ecs")
		fmt.Fprintln(file, "import (\n\t\"iter\"\n\t\"unsafe\"\n\n\t\"github.com/kjkrol/goke/internal/core\"\n)")

		genQueryFileContent(file, i)

		file.Close()
	}
}

func genQueryFileContent(f *os.File, n int) {
	allTypes := make([]string, n)
	for i := 0; i < n; i++ {
		allTypes[i] = fmt.Sprintf("T%d", i+1)
	}
	allTParams := strings.Join(allTypes, ", ")

	genQueryStructAndConstructor(f, n, allTParams)

	hCount, phCount := n, n
	if hCount > 3 {
		hCount = 3
	}
	if phCount > 4 {
		phCount = 4
	}

	hTParams := strings.Join(allTypes[:hCount], ", ")
	tTParams := ""
	if n > hCount {
		tTParams = strings.Join(allTypes[hCount:], ", ")
	}

	phTParams := strings.Join(allTypes[:phCount], ", ")
	ptTParams := ""
	if n > phCount {
		ptTParams = strings.Join(allTypes[phCount:], ", ")
	}

	genHeadTailStructs(f, n, allTypes, hCount, phCount)

	genAll(f, n, allTParams, hTParams, tTParams, hCount)
	genFilter(f, n, allTParams, hTParams, tTParams, hCount)
	genPureAll(f, n, allTParams, phTParams, ptTParams, phCount)
	genPureFilter(f, n, allTParams, phTParams, ptTParams, phCount)
}

func genQueryStructAndConstructor(f *os.File, n int, tParams string) {
	// Struct
	fmt.Fprintf(f, "\ntype Query%d[%s any] struct {\n\t*core.View\n}\n", n, tParams)

	// Constructor
	fmt.Fprintf(f, "\nfunc newQuery%d[%s any](reg *core.Registry, options ...ViewOption) *Query%d[%s] {\n", n, tParams, n, tParams)
	fmt.Fprintln(f, "\tviewBuilder := core.NewViewBuilder(reg)")

	// Register components
	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\tcore.OnCompType[T%d](viewBuilder)\n", i)
	}

	fmt.Fprintln(f, "\tfor _, opt := range options {\n\t\topt(viewBuilder)\n\t}")

	fmt.Fprintf(f, "\treturn &Query%d[%s]{View: viewBuilder.Build()}\n}\n", n, tParams)
}

func genHeadTailStructs(f *os.File, n int, allTypes []string, hCount, phCount int) {
	// Standard Head
	hTypes := strings.Join(allTypes[:hCount], ", ")
	fmt.Fprintf(f, "\ntype Head%d[%s any] struct {\n\tEntity Entity\n", n, hTypes)
	for i := 1; i <= hCount; i++ {
		fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
	}
	fmt.Fprintln(f, "}")

	// Standard Tail
	if n > hCount {
		tTypes := strings.Join(allTypes[hCount:], ", ")
		fmt.Fprintf(f, "type Tail%d[%s any] struct {\n", n, tTypes)
		for i := hCount + 1; i <= n; i++ {
			if i == 8 && n == 8 {
				fmt.Fprintf(f, "\tV8 *T8\n")
				break
			}
			if i > hCount+4 {
				break
			}
			fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
		}
		fmt.Fprintln(f, "}")
	}

	// Pure Head
	phTypes := strings.Join(allTypes[:phCount], ", ")
	fmt.Fprintf(f, "type PHead%d[%s any] struct {\n", n, phTypes)
	for i := 1; i <= phCount; i++ {
		fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
	}
	fmt.Fprintln(f, "}")

	// Pure Tail
	if n > phCount {
		ptTypes := strings.Join(allTypes[phCount:], ", ")
		fmt.Fprintf(f, "type PTail%d[%s any] struct {\n", n, ptTypes)
		for i := phCount + 1; i <= n; i++ {
			fmt.Fprintf(f, "\tV%d *T%d\n", i, i)
		}
		fmt.Fprintln(f, "}")
	}
}

func genAll(f *os.File, n int, allT, hT, tT string, hC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if n > hC {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}

	fmt.Fprintf(f, "\nfunc (q *Query%d[%s]) All%d() %s[%s] {\n", n, allT, n, seq, yield)
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n", yield)
	fmt.Fprintf(f, "\t\tfor i := range q.Baked {\n\t\t\tb := &q.Baked[i]\n") // q.Baked

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\tp%d, s%d := b.Columns[%d].Data, b.Columns[%d].ItemSize\n", i, i, i-1, i-1)
	}
	fmt.Fprintln(f, "\t\t\tfor j := 0; j < *b.Len; j++ {")

	hI := fmt.Sprintf("Head%d[%s]{Entity: (*b.Entities)[j]", n, hT)
	for i := 1; i <= hC; i++ {
		hI += fmt.Sprintf(", V%d: (*T%d)(p%d)", i, i, i)
	}
	hI += "}"

	if n > hC {
		tI := fmt.Sprintf("Tail%d[%s]{", n, tT)
		for i := hC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s) { return }\n", hI)
	}

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\t\tp%d = unsafe.Add(p%d, s%d)\n", i, i, i)
	}
	fmt.Fprintln(f, "\t\t\t}\n\t\t}\n\t}\n}")
}

func genFilter(f *os.File, n int, allT, hT, tT string, hC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("Head%d[%s]", n, hT)
	if n > hC {
		seq, yield = "iter.Seq2", fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, hT, n, tT)
	}

	fmt.Fprintf(f, "\nfunc (q *Query%d[%s]) Filter%d(entities []Entity) %s[%s] {\n", n, allT, n, seq, yield)
	fmt.Fprintf(f, "\tlinks := q.Reg.ArchetypeRegistry.EntityArchLinks\n") // q.reg
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n", yield)
	fmt.Fprintf(f, "\t\tvar lastArch *core.Archetype; var cols [%d]*core.Column\n", n)
	fmt.Fprintf(f, "\t\tfor _, e := range entities {\n")
	fmt.Fprintf(f, "\t\t\tlink := links[e.Index()]; arch := link.Arch\n")
	fmt.Fprintf(f, "\t\t\tif arch == nil || q.View.Matches(arch.Mask) { continue }\n")
	fmt.Fprintf(f, "\t\t\tif arch != lastArch { for i := 0; i < %d; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }\n", n) // q.CompIDs
	fmt.Fprintf(f, "\t\t\tidx := uintptr(link.Row)\n")

	hI := fmt.Sprintf("Head%d[%s]{Entity: e", n, hT)
	for i := 1; i <= hC; i++ {
		hI += fmt.Sprintf(", V%d: (*T%d)(unsafe.Add(cols[%d].Data, idx*cols[%d].ItemSize))", i, i, i-1, i-1)
	}
	hI += "}"

	if n > hC {
		tI := fmt.Sprintf("Tail%d[%s]{", n, tT)
		for i := hC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].Data, idx*cols[%d].ItemSize))%s", i, i, i-1, i-1, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\tif !yield(%s) { return }\n", hI)
	}
	fmt.Fprintln(f, "\t\t}\n\t}\n}")
}

func genPureAll(f *os.File, n int, allT, phT, ptT string, phC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("PHead%d[%s]", n, phT)
	if n > phC {
		seq, yield = "iter.Seq2", fmt.Sprintf("PHead%d[%s], PTail%d[%s]", n, phT, n, ptT)
	}

	fmt.Fprintf(f, "\nfunc (q *Query%d[%s]) PureAll%d() %s[%s] {\n", n, allT, n, seq, yield)
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n", yield)
	fmt.Fprintf(f, "\t\tfor i := range q.Baked {\n\t\t\tb := &q.Baked[i]\n")

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\tp%d, s%d := b.Columns[%d].Data, b.Columns[%d].ItemSize\n", i, i, i-1, i-1)
	}
	fmt.Fprintln(f, "\t\t\tfor j := 0; j < *b.Len; j++ {")

	hI := fmt.Sprintf("PHead%d[%s]{", n, phT)
	for i := 1; i <= phC; i++ {
		hI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < phC, ", ", ""))
	}
	hI += "}"

	if n > phC {
		tI := fmt.Sprintf("PTail%d[%s]{", n, ptT)
		for i := phC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(p%d)%s", i, i, i, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\t\tif !yield(%s) { return }\n", hI)
	}

	for i := 1; i <= n; i++ {
		fmt.Fprintf(f, "\t\t\t\tp%d = unsafe.Add(p%d, s%d)\n", i, i, i)
	}
	fmt.Fprintln(f, "\t\t\t}\n\t\t}\n\t}\n}")
}

func genPureFilter(f *os.File, n int, allT, phT, ptT string, phC int) {
	seq, yield := "iter.Seq", fmt.Sprintf("PHead%d[%s]", n, phT)
	if n > phC {
		seq, yield = "iter.Seq2", fmt.Sprintf("PHead%d[%s], PTail%d[%s]", n, phT, n, ptT)
	}

	fmt.Fprintf(f, "\nfunc (q *Query%d[%s]) PureFilter%d(entities []Entity) %s[%s] {\n", n, allT, n, seq, yield)
	fmt.Fprintf(f, "\tlinks := q.Reg.ArchetypeRegistry.EntityArchLinks\n")
	fmt.Fprintf(f, "\treturn func(yield func(%s) bool) {\n", yield)
	fmt.Fprintf(f, "\t\tvar lastArch *core.Archetype; var cols [%d]*core.Column\n", n)
	fmt.Fprintf(f, "\t\tfor _, e := range entities {\n")
	fmt.Fprintf(f, "\t\t\tlink := links[e.Index()]; arch := link.Arch\n")
	fmt.Fprintf(f, "\t\t\tif arch == nil || q.View.Matches(arch.Mask) { continue }\n")
	fmt.Fprintf(f, "\t\t\tif arch != lastArch { for i := 0; i < %d; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }; lastArch = arch }\n", n)
	fmt.Fprintf(f, "\t\t\tidx := uintptr(link.Row)\n")

	hI := fmt.Sprintf("PHead%d[%s]{", n, phT)
	for i := 1; i <= phC; i++ {
		hI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].Data, idx*cols[%d].ItemSize))%s", i, i, i-1, i-1, ternary(i < phC, ", ", ""))
	}
	hI += "}"

	if n > phC {
		tI := fmt.Sprintf("PTail%d[%s]{", n, ptT)
		for i := phC + 1; i <= n; i++ {
			tI += fmt.Sprintf("V%d: (*T%d)(unsafe.Add(cols[%d].Data, idx*cols[%d].ItemSize))%s", i, i, i-1, i-1, ternary(i < n, ", ", ""))
		}
		fmt.Fprintf(f, "\t\t\tif !yield(%s, %s}) { return }\n", hI, tI)
	} else {
		fmt.Fprintf(f, "\t\t\tif !yield(%s) { return }\n", hI)
	}
	fmt.Fprintln(f, "\t\t}\n\t}\n}")
}

func ternary(cond bool, a, b string) string {
	if cond {
		return a
	}
	return b
}
