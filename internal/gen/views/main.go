package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
)

type ViewData struct {
	N             int
	AllTParams    string
	Indices       []int
	HIndices      []int
	HTParams      string
	HasTail       bool
	TIndices      []int
	TTParams      string
	PHIndices     []int
	PHTParams     string
	HasVTail      bool
	PTIndices     []int
	PTTParams     string
	AllSeqType    string
	AllYieldArgs  string
	PureSeqType   string
	PureYieldArgs string
}

func main() {
	_, filename, _, _ := runtime.Caller(0)
	baseDir := filepath.Dir(filename)
	tmplPath := filepath.Join(baseDir, "view.go.tmpl")

	funcMap := template.FuncMap{
		"additions": func(a, b int) int { return a + b },
	}

	tmpl, err := template.New("view.go.tmpl").Funcs(funcMap).ParseFiles(tmplPath)
	if err != nil {
		fmt.Printf("Template file not found at: %s\n", tmplPath)
		panic(err)
	}

	outputName := "view_gen.go"
	f, err := os.Create(outputName)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	f.WriteString("// Code generated by gen/views; DO NOT EDIT.\n")
	f.WriteString("package ecs\n\n")
	f.WriteString("import (\n")
	f.WriteString("\t\"iter\"\n")
	f.WriteString("\t\"unsafe\"\n")
	f.WriteString("\t\"github.com/kjkrol/goke/internal/core\"\n")
	f.WriteString(")\n\n")

	for i := 1; i <= 8; i++ {
		data := prepareData(i)
		err = tmpl.Execute(f, data)
		if err != nil {
			fmt.Printf("Error during generation of View%d: %v\n", i, err)
			continue
		}
		f.WriteString("\n")
	}

	exec.Command("go", "fmt", outputName).Run()

	fmt.Printf("Success: All views merged into %s\n", outputName)
}

func prepareData(n int) ViewData {
	allTypes := make([]string, n)
	indices := make([]int, n)
	for i := 0; i < n; i++ {
		allTypes[i] = fmt.Sprintf("T%d", i+1)
		indices[i] = i
	}

	hCount := n
	if hCount > 3 {
		hCount = 3
	}
	phCount := n
	if phCount > 4 {
		phCount = 4
	}

	data := ViewData{
		N:          n,
		AllTParams: strings.Join(allTypes, ", "),
		Indices:    indices,
		HIndices:   indices[:hCount],
		HTParams:   strings.Join(allTypes[:hCount], ", "),
		PHIndices:  indices[:phCount],
		PHTParams:  strings.Join(allTypes[:phCount], ", "),
	}

	// Configure All/Filter
	if n > hCount {
		data.HasTail = true
		data.TIndices = indices[hCount:]
		data.TTParams = strings.Join(allTypes[hCount:], ", ")
		data.AllSeqType = fmt.Sprintf("iter.Seq2[Head%d[%s], Tail%d[%s]]", n, data.HTParams, n, data.TTParams)
		data.AllYieldArgs = fmt.Sprintf("Head%d[%s], Tail%d[%s]", n, data.HTParams, n, data.TTParams)
	} else {
		data.AllSeqType = fmt.Sprintf("iter.Seq[Head%d[%s]]", n, data.HTParams)
		data.AllYieldArgs = fmt.Sprintf("Head%d[%s]", n, data.HTParams)
	}

	// Configure Values/FilterValues
	if n > phCount {
		data.HasVTail = true
		data.PTIndices = indices[phCount:]
		data.PTTParams = strings.Join(allTypes[phCount:], ", ")
		data.PureSeqType = fmt.Sprintf("iter.Seq2[VHead%d[%s], VTail%d[%s]]", n, data.PHTParams, n, data.PTTParams)
		data.PureYieldArgs = fmt.Sprintf("VHead%d[%s], VTail%d[%s]", n, data.PHTParams, n, data.PTTParams)
	} else {
		data.PureSeqType = fmt.Sprintf("iter.Seq[VHead%d[%s]]", n, data.PHTParams)
		data.PureYieldArgs = fmt.Sprintf("VHead%d[%s]", n, data.PHTParams)
	}

	return data
}
