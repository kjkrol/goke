{{- /* File: view.go.tmpl */ -}}
type View{{.N}}[{{.AllTParams}} any] struct {
	*core.View
}

func NewView{{.N}}[{{.AllTParams}} any](ecs *ECS, opts ...BlueprintOption) *View{{.N}}[{{.AllTParams}}] {
	blueprint := core.NewBlueprint(ecs.registry)
	{{range .Indices}}
	comp{{additions . 1}}Info := core.EnsureComponentRegistered[T{{additions . 1}}](ecs.registry.ComponentsRegistry)
	blueprint.WithComp(comp{{additions . 1}}Info.ID)
	{{end}}
    for _, opt := range opts {
		opt(blueprint)
	}

	view := core.NewView(blueprint, ecs.registry)
	return &View{{.N}}[{{.AllTParams}}]{View: view}
}

// --- Head/Tail ---

type Head{{.N}}[{{.HTParams}} any] struct {
	Entity Entity
	{{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}
	{{end}}
}

{{if .HasTail}}
type Tail{{.N}}[{{.TTParams}} any] struct {
	{{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}
	{{end}}
}
{{end}}

type VHead{{.N}}[{{.PHTParams}} any] struct {
	{{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}
	{{end}}
}

{{if .HasVTail}}
type VTail{{.N}}[{{.PTTParams}} any] struct {
	{{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}
	{{end}}
}
{{end}}

// --- All / Filter ---

func (q *View{{.N}}[{{.AllTParams}}]) All() {{.AllSeqType}} {
	return func(yield func({{.AllYieldArgs}}) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			{{range .Indices}}p{{additions . 1}}, s{{additions . 1}} := b.Columns[{{.}}].Data, b.Columns[{{.}}].ItemSize
			{{end}}
			for j := 0; j < *b.Len; j++ {
				head := Head{{.N}}[{{.HTParams}}]{
					Entity: (*b.Entities)[j],
					{{- range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
				}
				{{if .HasTail}}
				tail := Tail{{.N}}[{{.TTParams}}]{
					{{- range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
				}
				if !yield(head, tail) { return }
				{{else}}
				if !yield(head) { return }
				{{end}}
				{{range .Indices}}p{{additions . 1}} = unsafe.Add(p{{additions . 1}}, s{{additions . 1}})
				{{end}}
			}
		}
	}
}

func (q *View{{.N}}[{{.AllTParams}}]) Filter(selected []Entity) {{.AllSeqType}} {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func({{.AllYieldArgs}}) bool) {
		var lastArch *core.Archetype; var cols [{{.N}}]*core.Column
		for _, e := range selected {
			link, ok := links.Get(e);
			if !ok {
				continue
			}
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) { continue }
			if arch != lastArch {
				for i := 0; i < {{.N}}; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }
				lastArch = arch
			}
			idx := uintptr(link.Row)
			head := Head{{.N}}[{{.HTParams}}]{
				Entity: e,
				{{- range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(cols[{{.}}].Data, idx*cols[{{.}}].ItemSize)),{{end}}
			}
			{{if .HasTail}}
			tail := Tail{{.N}}[{{.TTParams}}]{
				{{- range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(cols[{{.}}].Data, idx*cols[{{.}}].ItemSize)),{{end}}
			}
			if !yield(head, tail) { return }
			{{else}}
			if !yield(head) { return }
			{{end}}
		}
	}
}

// --- Values / FilterValues ---

func (q *View{{.N}}[{{.AllTParams}}]) Values() {{.PureSeqType}} {
	return func(yield func({{.PureYieldArgs}}) bool) {
		for i := range q.Baked {
			b := &q.Baked[i]
			{{range .Indices}}p{{additions . 1}}, s{{additions . 1}} := b.Columns[{{.}}].Data, b.Columns[{{.}}].ItemSize
			{{end}}
			for j := 0; j < *b.Len; j++ {
				vhead := VHead{{.N}}[{{.PHTParams}}]{
					{{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
				}
				{{if .HasVTail}}
				vtail := VTail{{.N}}[{{.PTTParams}}]{
					{{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
				}
				if !yield(vhead, vtail) { return }
				{{else}}
				if !yield(vhead) { return }
				{{end}}
				{{range .Indices}}p{{additions . 1}} = unsafe.Add(p{{additions . 1}}, s{{additions . 1}})
				{{end}}
			}
		}
	}
}

func (q *View{{.N}}[{{.AllTParams}}]) FilterValues(selected []Entity) {{.PureSeqType}} {
	links := q.Reg.ArchetypeRegistry.EntityLinkStore
	return func(yield func({{.PureYieldArgs}}) bool) {
		var lastArch *core.Archetype; var cols [{{.N}}]*core.Column
		for _, e := range selected {
			link, ok := links.Get(e);
			if !ok {
				continue
			}
			arch := link.Arch
			if arch == nil || !q.View.Matches(arch.Mask) { continue }
			if arch != lastArch {
				for i := 0; i < {{.N}}; i++ { cols[i] = arch.Columns[q.CompIDs[i]] }
				lastArch = arch
			}
			idx := uintptr(link.Row)
			vhead := VHead{{.N}}[{{.PHTParams}}]{
				{{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(cols[{{.}}].Data, idx*cols[{{.}}].ItemSize)),{{end}}
			}
			{{if .HasVTail}}
			vtail := VTail{{.N}}[{{.PTTParams}}]{
				{{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(cols[{{.}}].Data, idx*cols[{{.}}].ItemSize)),{{end}}
			}
			if !yield(vhead, vtail) { return }
			{{else}}
			if !yield(vhead) { return }
			{{end}}
		}
	}
}
