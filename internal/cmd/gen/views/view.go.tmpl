{{- /* File: view.go.tmpl */ -}}
// --------------- View{{.N}} ---------------

// View{{.N}} provides a type-safe iterator and access layer for entities that 
// possess exactly {{.N}} specific stateful components. It acts as a specialized 
// window into the ECS world, filtering archetypes that satisfy the required 
// component mask and any additional constraints defined via BlueprintOptions.
//
// By leveraging pre-calculated component offsets, View{{.N}} enables 
// O(1) access to component data during iteration, making it the primary 
// tool for implementing high-performance systems and logic loops.
type View{{.N}}[{{.AllTParams}} any] struct {
    *core.View
}

// NewView{{.N}} initializes a query for exactly {{.N}} components.
// It panics if the component registration fails, if there are duplicate 
// components, or if options (like Exclude) create a logical contradiction.
// 
// This ensures that the View is valid and ready for high-performance 
// iteration immediately after creation.
func NewView{{.N}}[{{.AllTParams}} any](ecs *ECS, opts ...BlueprintOption) *View{{.N}}[{{.AllTParams}}] {
    registry := ecs.registry
    blueprint := core.NewBlueprint(registry)
    componentsRegistry := &registry.ComponentsRegistry

    // Helper: Validates that the required component can be part of the view.
    mustAdd := func(info core.ComponentInfo) {
        if err := blueprint.WithComp(info); err != nil {
            panic(fmt.Sprintf("goke: view{{.N}} init failed: %v", err))
        }
    }

    // 1. Resolve Component Infos (Type -> ID)
    {{range .Indices}}
    info{{additions . 1}} := core.EnsureComponentRegistered[T{{additions . 1}}](componentsRegistry)
    {{end}}

    // 2. Add to Blueprint (Build Mask)
    {{range .Indices}}
    mustAdd(info{{additions . 1}})
    {{end}}

    // 3. Apply dynamic options (Include/Exclude)
    for _, opt := range opts {
        if err := opt(blueprint); err != nil {
            panic(fmt.Sprintf("goke: view{{.N}} option failed: %v", err))
        }
    }

    // 4. Define Rigid Layout (Slice Literal - Zero Allocation Overhead)
    // This guarantees that T1 is at index 0, T2 at index 1, etc.
    layout := []core.ComponentInfo{
        {{range .Indices}}info{{additions . 1}}, {{end}}
    }

    view := core.NewView(blueprint, layout, registry)
    return &View{{.N}}[{{.AllTParams}}]{View: view}
}

// All returns an iterator (iter.Seq2) that yields the unique Entity identifier 
// and a tuple of pointers to its {{.N}} components. This is designed for use 
// in range loops, providing a clean, idiomatic Go way to process data while 
// maintaining maximum cache efficiency.
//
// The iteration is performed archetype by archetype, ensuring that data is 
// accessed contiguously in memory, which significantly reduces CPU cache misses.
//
// Example usage:
//    for head, {{if .HasTail}}tail{{else}}_{{end}} := range view{{.N}}.All() {
//        entity := head.Entity
//        v1 := head.V1
//        {{- if .HasTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- else if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) All() iter.Seq2[
    struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        const strideEntity = unsafe.Sizeof(core.Entity(0))
        {{range .Indices}}s{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
        {{end}}
        for _, b := range v.Baked {
            
            // 1. Setup Entity Pointer
            pEntity := b.GetEntityColumn().Data

            // 2. Setup Component Pointers
            {{range .Indices}}p{{additions . 1}} := b.GetColumn({{.}}).Data
            {{end}}
            n := b.Arch.Len
            // Death Loop (Pointer Arithmetic)
            for n > 0 {
                
                // Construct Head
                head := struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                    Entity: *(*core.Entity)(pEntity),
                    {{- range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
                }

                // Construct Tail
                {{if .HasTail}}
                tail := struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                    {{- range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
                }
                {{else}}
                tail := struct{}{}
                {{end}}

                if !yield(head, tail) { return }

                // Increment Pointers
                pEntity = unsafe.Add(pEntity, strideEntity)
                {{range .Indices}}p{{additions . 1}} = unsafe.Add(p{{additions . 1}}, s{{additions . 1}})
                {{end}}
                n--
            }
        }
    }
}

// Filter returns an iterator (iter.Seq2) that yields only the entities 
// specified in the selected slice, provided they match the View's archetype 
// constraints. It is optimized for scenarios where a subset of entities 
// is pre-determined (e.g., via spatial partitioning or sorted results) 
// but requires high-speed access to their component data.
//
// The iterator performs an internal validation for each entity to ensure 
// it still belongs to an archetype compatible with this View, preventing 
// invalid memory access if the entity's composition has changed.
//
// Example usage:
//    selected := []Entity{e1, e5, e10}
//    for head, {{if .HasTail}}tail{{else}}_{{end}} := range view{{.N}}.Filter(selected) {
//        entity := head.Entity
//        v1 := head.V1
//        {{- if .HasTail}}
//        {{- range $i, $idx := .TIndices }}{{ if eq (additions $idx 1) $.N }}
//        v{{$.N}} := tail.V{{$.N}}
//        {{- end }}{{ end }}
//        {{- else if gt .N 1 }}
//        {{- range $i, $idx := .HIndices }}{{ if eq (additions $idx 1) $.N }}
//        v{{$.N}} := head.V{{$.N}}
//        {{- end }}{{ end }}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) Filter(selected []Entity) iter.Seq2[
    struct { Entity Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { Entity Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        {{range .Indices}}stride{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
        {{end}}
        var {{range $i, $_ := .Indices}}{{if $i}}, {{end}}ptr{{additions . 1}}{{end}} unsafe.Pointer
        var lastArchID int32 = -1
        registry := v.Reg.ArchetypeRegistry
        {{range .Indices}}col{{additions . 1}}ID := v.Layout[{{.}}].ID
        {{end}}

        for _, e := range selected {
            link, ok := registry.EntityLinkStore.Get(e)
            if !ok {
                continue
            }

            if int32(link.ArchId) != lastArchID {
                arch := &registry.Archetypes[link.ArchId]
                if !v.View.Matches(arch.Mask) {
                    lastArchID = -1
                    continue
                }

                {{range .Indices}}ptr{{additions . 1}} = arch.GetColumn(col{{additions . 1}}ID).Data
                {{end}}

                lastArchID = int32(link.ArchId)
            }

            row := uintptr(link.Row)

            head := struct { Entity Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                Entity: e,
                {{- range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(ptr{{additions . 1}}, row*stride{{additions . 1}})),{{end}}
            }
            {{if .HasTail}}
            tail := struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{- range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(ptr{{additions . 1}}, row*stride{{additions . 1}})),{{end}}
            }
            {{else}}
            tail := struct{}{}
            {{end}}

            if !yield(head, tail) {
                return
            }
        }
    }
}

// Values returns a performance-critical iterator (iter.Seq2) that yields only 
// component pointers, grouped into anonymous head and tail structures. 
// This method is specifically designed for high-throughput data processing 
// where the Entity identifier is not required.
//
// By omitting the Entity ID, this method minimizes stack pressure and 
// register usage, focusing purely on data-driven transformation.
//
// Example usage:
//    for head, {{if .HasVTail}}tail{{else}}_{{end}} := range view{{.N}}.Values() {
//        v1 := head.V1
//        {{- if le .N 4 }}{{ if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
{{- end }}{{ end }}
//        {{- if .HasVTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) Values() iter.Seq2[
    struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        // Calculate strides for types
        {{range .Indices}}s{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
        {{end}}

        for _, b := range v.Baked {
            
            // Setup Component Pointers
            {{range .Indices}}p{{additions . 1}} := b.GetColumn({{.}}).Data
            {{end}}
            
            n := b.Arch.Len

            // Death Loop (Pointer Arithmetic)
            for n > 0 {
                
                // Construct Head
                head := struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                    {{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
                }

                // Construct Tail
                {{if .HasVTail}}
                tail := struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                    {{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(p{{additions . 1}}),{{end}}
                }
                {{else}}
                tail := struct{}{}
                {{end}}

                if !yield(head, tail) { return }

                // Increment Pointers
                {{range .Indices}}p{{additions . 1}} = unsafe.Add(p{{additions . 1}}, s{{additions . 1}})
                {{end}}
                n--
            }
        }
    }
}

// FilterValues returns an iterator (iter.Seq2) that yields component pointers 
// for a pre-selected subset of entities, skipping the Entity identifier.
// It is optimized for cases where the entity list is already known (e.g., from spatial partitioning).
//
// Like the Values method, it uses anonymous structures to ensure the Go compiler 
// can perform aggressive register allocation by avoiding Entity ID overhead.
//
// Example usage:
//    selected := []Entity{e1, e5, e10}
//    for head, {{if .HasVTail}}tail{{else}}_{{end}} := range view{{.N}}.FilterValues(selected) {
//        v1 := head.V1
//        {{- if le .N 4 }}{{ if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
{{- end }}{{ end }}
//        {{- if .HasVTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) FilterValues(selected []Entity) iter.Seq2[
    struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        {{range .Indices}}stride{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
        {{end}}
        var {{range $i, $_ := .Indices}}{{if $i}}, {{end}}ptr{{additions . 1}}{{end}} unsafe.Pointer
        var lastArchID int32 = -1
        registry := v.Reg.ArchetypeRegistry
        {{range .Indices}}col{{additions . 1}}ID := v.Layout[{{.}}].ID
        {{end}}

        for _, e := range selected {
            link, ok := registry.EntityLinkStore.Get(e)
            if !ok {
                continue
            }

            if int32(link.ArchId) != lastArchID {
                arch := &registry.Archetypes[link.ArchId]
                if !v.View.Matches(arch.Mask) {
                    lastArchID = -1
                    continue
                }

                {{range .Indices}}ptr{{additions . 1}} = arch.GetColumn(col{{additions . 1}}ID).Data
                {{end}}

                lastArchID = int32(link.ArchId)
            }

            row := uintptr(link.Row)

            vhead := struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(ptr{{additions . 1}}, row*stride{{additions . 1}})),{{end}}
            }
            {{if .HasVTail}}
            vtail := struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(unsafe.Add(ptr{{additions . 1}}, row*stride{{additions . 1}})),{{end}}
            }
            {{else}}
            vtail := struct{}{}
            {{end}}

            if !yield(vhead, vtail) {
                return
            }
        }
    }
}
