{{- /* File: view.go.tmpl */ -}}
// --------------- View{{.N}} ---------------

// View{{.N}} provides a type-safe iterator and access layer for entities that 
// possess exactly {{.N}} specific stateful components. It acts as a specialized 
// window into the ECS world, filtering archetypes that satisfy the required 
// component mask and any additional constraints defined via BlueprintOptions.
//
// By leveraging pre-calculated component offsets, View{{.N}} enables 
// O(1) access to component data during iteration, making it the primary 
// tool for implementing high-performance systems and logic loops.
type View{{.N}}[{{.AllTParams}} any] struct {
    *core.View
}

// NewView{{.N}} initializes a query for exactly {{.N}} components.
// It panics if the component registration fails, if there are duplicate 
// components, or if options (like Exclude) create a logical contradiction.
// 
// This ensures that the View is valid and ready for high-performance 
// iteration immediately after creation.
func NewView{{.N}}[{{.AllTParams}} any](ecs *ECS, opts ...BlueprintOption) *View{{.N}}[{{.AllTParams}}] {
    registry := ecs.registry
    blueprint := core.NewBlueprint(registry)
    componentsRegistry := &registry.ComponentsRegistry

    // Helper: Validates that the required component can be part of the view.
    mustAdd := func(info core.ComponentInfo) {
        if err := blueprint.WithComp(info); err != nil {
            panic(fmt.Sprintf("goke: view{{.N}} init failed: %v", err))
        }
    }

    // 1. Resolve Component Infos (Type -> ID)
    {{range .Indices}}
    info{{additions . 1}} := componentsRegistry.GetOrRegister(reflect.TypeFor[T{{additions . 1}}]())
    {{end}}

    // 2. Add to Blueprint (Build Mask)
    {{range .Indices}}
    mustAdd(info{{additions . 1}})
    {{end}}

    // 3. Apply dynamic options (Include/Exclude)
    for _, opt := range opts {
        if err := opt(blueprint); err != nil {
            panic(fmt.Sprintf("goke: view{{.N}} option failed: %v", err))
        }
    }

    // 4. Define Rigid Layout (Slice Literal - Zero Allocation Overhead)
    // This guarantees that T1 is at index 0, T2 at index 1, etc.
    layout := []core.ComponentInfo{
        {{range .Indices}}info{{additions . 1}}, {{end}}
    }

    view := core.NewView(blueprint, layout, registry)
    return &View{{.N}}[{{.AllTParams}}]{View: view}
}

// All returns an iterator (iter.Seq2) that yields the unique Entity identifier 
// and a tuple of pointers to its {{.N}} components. This is designed for use 
// in range loops, providing a clean, idiomatic Go way to process data while 
// maintaining maximum cache efficiency.
//
// The iteration is performed archetype by archetype, ensuring that data is 
// accessed contiguously in memory, which significantly reduces CPU cache misses.
//
// Example usage:
//    for head, {{if .HasTail}}tail{{else}}_{{end}} := range view{{.N}}.All() {
//        entity := head.Entity
//        v1 := head.V1
//        {{- if .HasTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- else if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) All() iter.Seq2[
    struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    // 1. Pre-calculate Strides (Invariant)
    const strideEntity = unsafe.Sizeof(core.Entity(0))
    {{range .Indices}}stride{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
    {{end}}

    return func(yield func(
        struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {

        // Loop over matched archetypes
        for _, ma := range v.Baked {
            // 2. Get Column Accessors for this Archetype
            colEntity := ma.GetEntityColumn()
            {{range .Indices}}col{{additions . 1}} := ma.GetColumn({{ . }})
            {{end}}

            // 3. Loop over Physical Memory Pages (CHUNKS)
            for _, chunk := range ma.Arch.Memory.Pages {
                count := chunk.Len // Using ChunkRow type
                if count == 0 {
                    continue
                }

                // 4. Resolve Base Pointers for this Chunk
                ptrEntity := colEntity.GetPointer(chunk, 0)
                {{range .Indices}}ptr{{additions . 1}} := col{{additions . 1}}.GetPointer(chunk, 0)
                {{end}}

                // 5. Hot Loop (Death Loop)
                for count > 0 {
                    // Construct Head
                    head := struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                        Entity: *(*core.Entity)(ptrEntity),
                        {{range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(ptr{{additions . 1}}),
                        {{end}}
                    }

                    // Construct Tail (if exists)
                    {{if .HasTail}}
                    tail := struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                        {{range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(ptr{{additions . 1}}),
                        {{end}}
                    }
                    {{else}}
                    tail := struct{}{}
                    {{end}}

                    // Yield execution to the user
                    if !yield(head, tail) {
                        return
                    }

                    // 6. Pointer Arithmetic (Move to next row)
                    ptrEntity = unsafe.Add(ptrEntity, strideEntity)
                    {{range .Indices}}ptr{{additions . 1}} = unsafe.Add(ptr{{additions . 1}}, stride{{additions . 1}})
                    {{end}}

                    count--
                }
            }
        }
    }
}

// Filter returns an iterator (iter.Seq2) that yields only the entities 
// specified in the selected slice, provided they match the View's archetype 
// constraints. It is optimized for scenarios where a subset of entities 
// is pre-determined (e.g., via spatial partitioning or sorted results) 
// but requires high-speed access to their component data.
//
// The iterator performs an internal validation for each entity to ensure 
// it still belongs to an archetype compatible with this View, preventing 
// invalid memory access if the entity's composition has changed.
//
// Example usage:
//    selected := []Entity{e1, e5, e10}
//    for head, {{if .HasTail}}tail{{else}}_{{end}} := range view{{.N}}.Filter(selected) {
//        entity := head.Entity
//        v1 := head.V1
//        {{- if .HasTail}}
//        {{- range $i, $idx := .TIndices }}{{ if eq (additions $idx 1) $.N }}
//        v{{$.N}} := tail.V{{$.N}}
//        {{- end }}{{ end }}
//        {{- else if gt .N 1 }}
//        {{- range $i, $idx := .HIndices }}{{ if eq (additions $idx 1) $.N }}
//        v{{$.N}} := head.V{{$.N}}
//        {{- end }}{{ end }}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) Filter(selected []Entity) iter.Seq2[
    struct { Entity Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasTail}}struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        var lastArchID core.ArchetypeId = core.NullArchetypeId
        var currentArch *core.Archetype
        
        // Column descriptor cache
        {{range .Indices}}var col{{additions . 1}} *core.Column
        {{end}}

        registry := v.Reg.ArchetypeRegistry

        for _, e := range selected {
            link, ok := registry.EntityLinkStore.Get(e)
            if !ok {
                continue
            }

            // 1. Archetype Change Detection (Cache descriptors)
            if link.ArchId != lastArchID {
                currentArch = &registry.Archetypes[link.ArchId]
                
                if !v.View.Matches(currentArch.Mask) {
                    lastArchID = core.NullArchetypeId
                    currentArch = nil
                    continue
                }

                // Cache all column descriptors for this archetype
                {{range .Indices}}col{{additions . 1}} = currentArch.GetColumn(v.Layout[{{ . }}].ID)
                {{end}}
                
                lastArchID = link.ArchId
            }

            if currentArch == nil {
                continue
            }

            // 2. Resolve Chunk
            // Access the physical page using the index from the link
            chunk := currentArch.Memory.Pages[link.ChunkIdx]

            // 3. Construct Result (Head)
            head := struct { Entity core.Entity; {{range .HIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                Entity: e,
                {{range .HIndices}}V{{additions . 1}}: (*T{{additions . 1}})(col{{additions . 1}}.GetPointer(chunk, link.ChunkRow)),
                {{end}}
            }

            // 4. Construct Result (Tail)
            {{if .HasTail}}
            tail := struct { {{range .TIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{range .TIndices}}V{{additions . 1}}: (*T{{additions . 1}})(col{{additions . 1}}.GetPointer(chunk, link.ChunkRow)),
                {{end}}
            }
            {{else}}
            tail := struct{}{}
            {{end}}

            if !yield(head, tail) {
                return
            }
        }
    }
}

// Values returns a performance-critical iterator (iter.Seq2) that yields only 
// component pointers, grouped into anonymous head and tail structures. 
// This method is specifically designed for high-throughput data processing 
// where the Entity identifier is not required.
//
// By omitting the Entity ID, this method minimizes stack pressure and 
// register usage, focusing purely on data-driven transformation.
//
// Example usage:
//    for head, {{if .HasVTail}}tail{{else}}_{{end}} := range view{{.N}}.Values() {
//        v1 := head.V1
//        {{- if le .N 4 }}{{ if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
{{- end }}{{ end }}
//        {{- if .HasVTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) Values() iter.Seq2[
    struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    // 1. Pre-calculate Strides (Invariant)
    // We calculate type sizes once, outside the loops.
    {{range .Indices}}s{{additions . 1}} := unsafe.Sizeof(*new(T{{additions . 1}}))
    {{end}}

    return func(yield func(
        struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {

        // Loop over matched archetypes
        for _, ma := range v.Baked {
            
            // 2. Get Column Accessors for this Archetype
            {{range .Indices}}col{{additions . 1}} := ma.GetColumn({{ . }})
            {{end}}

            // 3. Loop over Physical Memory Pages (CHUNKS)
            for _, chunk := range ma.Arch.Memory.Pages {
                count := chunk.Len 
                if count == 0 {
                    continue
                }

                // 4. Resolve Base Pointers for this Chunk
                // Starting at row 0 for each column in this specific chunk.
                {{range .Indices}}ptr{{additions . 1}} := col{{additions . 1}}.GetPointer(chunk, 0)
                {{end}}

                // 5. Hot Loop (Death Loop)
                // Direct pointer arithmetic within the 16KB contiguous chunk.
                for count > 0 {
                    
                    // Construct Head
                    head := struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                        {{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(ptr{{additions . 1}}),{{end}}
                    }

                    // Construct Tail
                    {{if .HasVTail}}
                    tail := struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                        {{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(ptr{{additions . 1}}),{{end}}
                    }
                    {{else}}
                    tail := struct{}{}
                    {{end}}

                    if !yield(head, tail) { return }

                    // 6. Increment Pointers (Pointer Arithmetic)
                    // Move to the next row using pre-calculated strides.
                    {{range .Indices}}ptr{{additions . 1}} = unsafe.Add(ptr{{additions . 1}}, s{{additions . 1}})
                    {{end}}
                    
                    count--
                }
            }
        }
    }
}

// FilterValues returns an iterator (iter.Seq2) that yields component pointers 
// for a pre-selected subset of entities, skipping the Entity identifier.
// It is optimized for cases where the entity list is already known (e.g., from spatial partitioning).
//
// Like the Values method, it uses anonymous structures to ensure the Go compiler 
// can perform aggressive register allocation by avoiding Entity ID overhead.
//
// Example usage:
//    selected := []Entity{e1, e5, e10}
//    for head, {{if .HasVTail}}tail{{else}}_{{end}} := range view{{.N}}.FilterValues(selected) {
//        v1 := head.V1
//        {{- if le .N 4 }}{{ if gt .N 1 }}
//        v{{.N}} := head.V{{.N}}
{{- end }}{{ end }}
//        {{- if .HasVTail }}
//        v{{.N}} := tail.V{{.N}}
//        {{- end }}
//    }
func (v *View{{.N}}[{{.AllTParams}}]) FilterValues(selected []core.Entity) iter.Seq2[
    struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
    {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
] {
    return func(yield func(
        struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} },
        {{if .HasVTail}}struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{{else}}struct{}{{end}},
    ) bool) {
        var lastArchID core.ArchetypeId = core.NullArchetypeId
        var currentArch *core.Archetype
        
        // Cache for column descriptors to avoid repeated map lookups
        {{range .Indices}}var col{{additions . 1}} *core.Column
        {{end}}

        registry := v.Reg.ArchetypeRegistry

        for _, e := range selected {
            link, ok := registry.EntityLinkStore.Get(e)
            if !ok {
                continue
            }

            // 1. Archetype Transition Detection
            // We only refresh column descriptors when the archetype changes.
            if link.ArchId != lastArchID {
                currentArch = &registry.Archetypes[link.ArchId]
                
                // Verify if the archetype matches the view's mask requirements
                if !v.View.Matches(currentArch.Mask) {
                    lastArchID = core.NullArchetypeId
                    currentArch = nil
                    continue
                }

                // Cache column accessors for this specific archetype
                {{range .Indices}}col{{additions . 1}} = currentArch.GetColumn(v.Layout[{{.}}].ID)
                {{end}}

                lastArchID = link.ArchId
            }

            // If currentArch is nil, it means the current entity's archetype doesn't match the view
            if currentArch == nil {
                continue
            }

            // 2. Resolve Physical Chunk
            // Access the memory page (Chunk) using the index from the link store.
            chunk := currentArch.Memory.Pages[link.ChunkIdx]

            // 3. Construct Result (Head)
            vhead := struct { {{range .PHIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{- range .PHIndices}}V{{additions . 1}}: (*T{{additions . 1}})(col{{additions . 1}}.GetPointer(chunk, link.ChunkRow)),{{end}}
            }

            // 4. Construct Result (Tail)
            {{if .HasVTail}}
            vtail := struct { {{range .PTIndices}}V{{additions . 1}} *T{{additions . 1}}; {{end}} }{
                {{- range .PTIndices}}V{{additions . 1}}: (*T{{additions . 1}})(col{{additions . 1}}.GetPointer(chunk, link.ChunkRow)),{{end}}
            }
            {{else}}
            vtail := struct{}{}
            {{end}}

            if !yield(vhead, vtail) {
                return
            }
        }
    }
}